(declare-const prt Bool)
(declare-const circuit Bool)
(declare-const red_SR Bool)
(declare-const red_MR Bool)
(declare-const org_SR Bool)
(declare-const grn_SR Bool)
(declare-const org_MR Bool)
(declare-const grn_MR Bool)
(declare-const grn Bool)
(declare-const org Bool)
(declare-const rd1 Bool)
(declare-const rd2 Bool)
(define @t1 () (not rd2))
(define @t2 () (not rd1))
(define @t3 () (not org))
(define @t4 () (or grn rd1))
(define @t5 () (and rd1 prt))
(define @t6 () (not prt))
(define @t7 () (and grn @t6))
(define @t8 () (and @t6 rd1))
(define @t9 () (and prt grn))
(define @t10 () (or @t9 org @t8 rd2 @t7 @t5))
(define @t11 () (not @t10))
(define @t12 () (= prt prt))
(define @t13 () (not @t6))
(define @t14 () (= @t13 prt))
(define @t15 () (= prt @t13))
(define @t16 () (or prt @t2))
(define @t17 () (or @t13 @t2))
(define @t18 () (and grn_MR @t6))
(define @t19 () (and prt grn_MR))
(define @t20 () (or @t19 @t8 @t18 @t5))
(define @t21 () (or @t19 false @t8 false @t18 @t5))
(define @t22 () (= @t21 @t20))
(define @t23 () (not @t20))
(define @t24 () (not @t21))
(define @t25 () (= rd2 false))
(define @t26 () (not org_MR))
(define @t27 () (= org_MR false))
(define @t28 () (@list false))
(define @t29 () (or grn_MR rd1))
(define @t30 () (not grn_MR))
(define @t31 () (or @t30 prt))
(define @t32 () (or @t30 @t13))
(define @t33 () (or prt @t30))
(assume @p1 (=> grn (and @t3 @t2 @t1)))
(assume @p2 (=> rd1 @t1))
(assume @p3 (= grn_MR grn))
(assume @p4 (= org_MR org))
(assume @p5 (= grn_SR rd1))
(assume @p6 (= org_SR rd2))
(assume @p7 (= red_MR (or grn_SR org_SR)))
(assume @p8 (= red_SR (or grn_MR org_MR)))
(assume @p9 circuit)
(assume @p10 @t4)
(assume @p11 (= red_MR rd1))
(assume @p12 (= red_SR grn))
(assume @p13 @t11)
(step @p14 (= @t2 @t2) :rule refl :args (@t2))
(step @p15 (= @t12 true) :rule eq-refl :args (prt))
(step @p16 @t14 :rule bool-double-not-elim :args (prt))
(step @p17 @t12 :rule refl :args (prt))
(step @p18 (= @t15 @t12) :rule cong :premises (@p17 @p16) :args (@t15))
(step @p19 (= @t15 true) :rule trans :premises (@p18 @p15))
(step @p20 (= @t14 @t15) :rule eq-symm :args (@t13 prt))
(step @p21 (= @t14 true) :rule trans :premises (@p20 @p19))
(step @p22 @t14 :rule true_elim :premises (@p21))
(step @p23 (= @t17 @t16) :rule nary_cong :premises (@p22 @p14) :args (@t17))
(step @p24 @t22 :rule aci_norm :args (@t22))
(step @p25 (= @t24 @t23) :rule cong :premises (@p24) :args (@t24))
(step @p26 (= @t5 @t5) :rule refl :args (@t5))
(step @p27 (= @t6 @t6) :rule refl :args (@t6))
(step @p28 (= grn grn_MR) :rule symm :premises (@p3))
(step @p29 (= @t7 @t18) :rule nary_cong :premises (@p28 @p27) :args (@t7))
(step @p30 (= @t25 @t1) :rule bool-eq-false :args (rd2))
(step @p31 (= @t1 @t25) :rule symm :premises (@p30))
(step @p32 @t1 :rule not_or_elim :premises (@p13) :args (3))
(step @p33 @t25 :rule eq_resolve :premises (@p32 @p31))
(step @p34 (= @t8 @t8) :rule refl :args (@t8))
(step @p35 (= @t27 @t26) :rule bool-eq-false :args (org_MR))
(step @p36 (= @t26 @t27) :rule symm :premises (@p35))
(step @p37 @t3 :rule not_or_elim :premises (@p13) :args (1))
(step @p38 (= org org_MR) :rule symm :premises (@p4))
(step @p39 (or org @t26) :rule equiv_elim2 :premises (@p38))
(step @p40 @t26 :rule resolution :premises (@p39 @p37) :args (true org))
(step @p41 @t27 :rule eq_resolve :premises (@p40 @p36))
(step @p42 (= org false) :rule trans :premises (@p38 @p41))
(step @p43 (= @t9 @t19) :rule nary_cong :premises (@p17 @p28) :args (@t9))
(step @p44 (= @t10 @t21) :rule nary_cong :premises (@p43 @p42 @p34 @p33 @p29 @p26) :args (@t10))
(step @p45 (= @t11 @t24) :rule cong :premises (@p44) :args (@t11))
(step @p46 (= @t11 @t23) :rule trans :premises (@p45 @p25))
(step @p47 @t23 :rule eq_resolve :premises (@p13 @p46))
(step @p48 (not @t8) :rule not_or_elim :premises (@p47) :args (1))
(step @p49 @t17 :rule not_and :premises (@p48))
(step @p50 @t16 :rule eq_resolve :premises (@p49 @p23))
(step @p51 (not @t5) :rule not_or_elim :premises (@p47) :args (3))
(step @p52 (or @t2 @t6) :rule not_and :premises (@p51))
(step @p53 (or @t2 @t2) :rule chain_resolution :premises (@p52 @p50) :args (@t28 (@list prt)))
(step @p54 @t2 :rule factoring :premises (@p53))
(step @p55 (= rd1 rd1) :rule refl :args (rd1))
(step @p56 (= @t4 @t29) :rule nary_cong :premises (@p28 @p55) :args (@t4))
(step @p57 @t29 :rule eq_resolve :premises (@p10 @p56))
(step @p58 grn_MR :rule chain_resolution :premises (@p57 @p54) :args ((@list true) (@list rd1)))
(step @p59 (not @t19) :rule not_or_elim :premises (@p47) :args (0))
(step @p60 (or @t6 @t30) :rule not_and :premises (@p59))
(step @p61 @t6 :rule chain_resolution :premises (@p60 @p58) :args (@t28 (@list grn_MR)))
(step @p62 (= @t30 @t30) :rule refl :args (@t30))
(step @p63 (= @t32 @t31) :rule nary_cong :premises (@p62 @p22) :args (@t32))
(step @p64 (not @t18) :rule not_or_elim :premises (@p47) :args (2))
(step @p65 @t32 :rule not_and :premises (@p64))
(step @p66 @t31 :rule eq_resolve :premises (@p65 @p63))
(step @p67 @t33 :rule reordering :premises (@p66) :args (@t33))
(step @p68 false :rule chain_resolution :premises (@p67 @p61 @p58) :args ((@list true false) (@list prt grn_MR)))
