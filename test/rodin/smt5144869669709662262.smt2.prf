(declare-type Z ())
(declare-const reg Bool)
(declare-const input Bool)
(declare-const nf0 Z)
(declare-const flash Z)
(declare-const nf Z)
(declare-const circuit Bool)
(define @t1 () (= flash nf))
(define @t2 () (= flash nf0))
(define @t3 () (= nf nf0))
(define @t4 () (not @t3))
(define @t5 () (= nf0 flash))
(define @t6 () (not @t5))
(define @t7 () (not true))
(define @t8 () (= nf0 nf0))
(define @t9 () (not @t8))
(define @t10 () (not @t2))
(define @t11 () (not @t4))
(assume @p1 (not circuit))
(assume @p2 (or @t2 @t1))
(assume @p3 (=> @t4 (not @t1)))
(assume @p4 (=> @t4 @t2))
(assume @p5 (= reg input))
(assume @p6 @t6)
(step @p7 (= @t7 false) :rule evaluate :args (@t7))
(step @p8 (= @t8 true) :rule eq-refl :args (nf0))
(step @p9 (= @t9 @t7) :rule cong :premises (@p8) :args (@t9))
(step @p10 (= @t9 false) :rule trans :premises (@p9 @p7))
(step @p11 @t8 :rule refl :args (nf0))
(step @p12 @t10 :rule symm :premises (@p6))
(step @p13 (or @t11 @t2) :rule implies_elim :premises (@p4))
(step @p14 @t11 :rule resolution :premises (@p13 @p12) :args (true @t2))
(step @p15 @t3 :rule not_not_elim :premises (@p14))
(step @p16 @t1 :rule chain_resolution :premises (@p2 @p12) :args ((@list true) (@list @t2)))
(step @p17 @t2 :rule trans :premises (@p16 @p15))
(step @p18 (= @t2 @t8) :rule cong :premises (@p17 @p11) :args (@t2))
(step @p19 (= @t10 @t9) :rule cong :premises (@p18) :args (@t10))
(step @p20 (= @t10 false) :rule trans :premises (@p19 @p10))
(step @p21 (= @t5 @t2) :rule eq-symm :args (nf0 flash))
(step @p22 (= @t6 @t10) :rule cong :premises (@p21) :args (@t6))
(step @p23 (= @t6 false) :rule trans :premises (@p22 @p20))
(step @p24 false :rule eq_resolve :premises (@p6 @p23))
