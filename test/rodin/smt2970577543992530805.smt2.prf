(declare-type Z ())
(declare-type MODE ())
(declare-const p2 Bool)
(declare-const p1 Bool)
(declare-const i2 Bool)
(declare-const r2 Z)
(declare-const i1 Bool)
(declare-const r1 Z)
(declare-const a2 Z)
(declare-const b2 Z)
(declare-const a1 Z)
(declare-const b1 Z)
(declare-const mode MODE)
(declare-const cir MODE)
(define @t1 () (= r1 b1))
(define @t2 () (not i1))
(define @t3 () (= r2 b2))
(define @t4 () (not i2))
(define @t5 () (= @t4 @t3))
(define @t6 () (not p1))
(define @t7 () (not p2))
(define @t8 () (=> @t3 @t7))
(define @t9 () (and @t2 @t4))
(define @t10 () (or @t2 p2))
(define @t11 () (and i2 @t10))
(define @t12 () (and i1 @t7))
(define @t13 () (= p2 p2))
(define @t14 () (not @t7))
(define @t15 () (= @t14 p2))
(define @t16 () (= p2 @t14))
(define @t17 () (or @t2 @t14))
(define @t18 () (= i1 i1))
(define @t19 () (not @t2))
(define @t20 () (= @t19 i1))
(define @t21 () (= i1 @t19))
(define @t22 () (or @t10 i1))
(define @t23 () (or @t10 @t19))
(define @t24 () (or i1 @t10))
(define @t25 () (= i2 i2))
(define @t26 () (not @t4))
(define @t27 () (= @t26 i2))
(define @t28 () (= i2 @t26))
(define @t29 () (or i1 i2))
(define @t30 () (or @t19 @t26))
(define @t31 () (@list false false))
(define @t32 () (@list i2 @t10))
(define @t33 () (or p2 @t2))
(define @t34 () (@list false))
(define @t35 () (= b2 r2))
(define @t36 () (=> @t35 @t7))
(define @t37 () (not @t35))
(define @t38 () (or @t7 @t37))
(define @t39 () (or i2 @t35))
(define @t40 () (or @t26 @t35))
(define @t41 () (= @t4 @t35))
(assume @p1 (= mode cir))
(assume @p2 (= a1 b1))
(assume @p3 (= a2 b2))
(assume @p4 (= @t2 @t1))
(assume @p5 @t5)
(assume @p6 (=> @t1 @t6))
(assume @p7 @t8)
(assume @p8 (or (and (not @t1) @t7) (and (not @t3) @t6) (and @t1 @t3)))
(assume @p9 (not (or @t12 @t11 @t9)))
(step @p10 (= @t13 true) :rule eq-refl :args (p2))
(step @p11 @t15 :rule bool-double-not-elim :args (p2))
(step @p12 @t13 :rule refl :args (p2))
(step @p13 (= @t16 @t13) :rule cong :premises (@p12 @p11) :args (@t16))
(step @p14 (= @t16 true) :rule trans :premises (@p13 @p10))
(step @p15 (= @t15 @t16) :rule eq-symm :args (@t14 p2))
(step @p16 (= @t15 true) :rule trans :premises (@p15 @p14))
(step @p17 @t15 :rule true_elim :premises (@p16))
(step @p18 (= @t2 @t2) :rule refl :args (@t2))
(step @p19 (= @t17 @t10) :rule nary_cong :premises (@p18 @p17) :args (@t17))
(step @p20 (not @t12) :rule not_or_elim :premises (@p9) :args (0))
(step @p21 @t17 :rule not_and :premises (@p20))
(step @p22 @t10 :rule eq_resolve :premises (@p21 @p19))
(step @p23 (= @t18 true) :rule eq-refl :args (i1))
(step @p24 @t20 :rule bool-double-not-elim :args (i1))
(step @p25 @t18 :rule refl :args (i1))
(step @p26 (= @t21 @t18) :rule cong :premises (@p25 @p24) :args (@t21))
(step @p27 (= @t21 true) :rule trans :premises (@p26 @p23))
(step @p28 (= @t20 @t21) :rule eq-symm :args (@t19 i1))
(step @p29 (= @t20 true) :rule trans :premises (@p28 @p27))
(step @p30 @t20 :rule true_elim :premises (@p29))
(step @p31 (= @t10 @t10) :rule refl :args (@t10))
(step @p32 (= @t23 @t22) :rule nary_cong :premises (@p31 @p30) :args (@t23))
(step @p33 @t23 :rule cnf_or_neg :args (@t10 0))
(step @p34 @t22 :rule eq_resolve :premises (@p33 @p32))
(step @p35 @t24 :rule reordering :premises (@p34) :args (@t24))
(step @p36 (= @t25 true) :rule eq-refl :args (i2))
(step @p37 @t27 :rule bool-double-not-elim :args (i2))
(step @p38 @t25 :rule refl :args (i2))
(step @p39 (= @t28 @t25) :rule cong :premises (@p38 @p37) :args (@t28))
(step @p40 (= @t28 true) :rule trans :premises (@p39 @p36))
(step @p41 (= @t27 @t28) :rule eq-symm :args (@t26 i2))
(step @p42 (= @t27 true) :rule trans :premises (@p41 @p40))
(step @p43 @t27 :rule true_elim :premises (@p42))
(step @p44 (= @t30 @t29) :rule nary_cong :premises (@p30 @p43) :args (@t30))
(step @p45 (not @t9) :rule not_or_elim :premises (@p9) :args (2))
(step @p46 @t30 :rule not_and :premises (@p45))
(step @p47 @t29 :rule eq_resolve :premises (@p46 @p44))
(step @p48 (not @t11) :rule not_or_elim :premises (@p9) :args (1))
(step @p49 (or @t4 (not @t10)) :rule not_and :premises (@p48))
(step @p50 (or i1 i1) :rule chain_resolution :premises (@p49 @p47 @p35) :args (@t31 @t32))
(step @p51 i1 :rule factoring :premises (@p50))
(step @p52 @t33 :rule reordering :premises (@p22) :args (@t33))
(step @p53 p2 :rule chain_resolution :premises (@p52 @p51) :args (@t34 (@list i1)))
(step @p54 (= @t7 @t7) :rule refl :args (@t7))
(step @p55 (= @t3 @t35) :rule eq-symm :args (r2 b2))
(step @p56 (= @t8 @t36) :rule cong :premises (@p55 @p54) :args (@t8))
(step @p57 @t36 :rule eq_resolve :premises (@p7 @p56))
(step @p58 (or @t37 @t7) :rule implies_elim :premises (@p57))
(step @p59 @t38 :rule reordering :premises (@p58) :args (@t38))
(step @p60 @t37 :rule chain_resolution :premises (@p59 @p53) :args (@t34 (@list p2)))
(step @p61 (= @t35 @t35) :rule refl :args (@t35))
(step @p62 (= @t40 @t39) :rule nary_cong :premises (@p43 @p61) :args (@t40))
(step @p63 (= @t4 @t4) :rule refl :args (@t4))
(step @p64 (= @t5 @t41) :rule cong :premises (@p63 @p55) :args (@t5))
(step @p65 @t41 :rule eq_resolve :premises (@p5 @p64))
(step @p66 @t40 :rule equiv_elim1 :premises (@p65))
(step @p67 @t39 :rule eq_resolve :premises (@p66 @p62))
(step @p68 i2 :rule chain_resolution :premises (@p67 @p60) :args ((@list true) (@list @t35)))
(step @p69 false :rule chain_resolution :premises (@p49 @p68 @p22) :args (@t31 @t32))
