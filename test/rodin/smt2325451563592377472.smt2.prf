(declare-const prt Bool)
(declare-const car Bool)
(declare-const clk Bool)
(declare-const circuit Bool)
(define @t1 () (not clk))
(define @t2 () (and prt car @t1))
(define @t3 () (not car))
(define @t4 () (or @t3 @t1))
(define @t5 () (not prt))
(define @t6 () (and @t5 @t4))
(define @t7 () (or @t3 clk))
(define @t8 () (and prt @t7))
(define @t9 () (and @t5 car clk))
(define @t10 () (not @t4))
(define @t11 () (= prt prt))
(define @t12 () (not @t5))
(define @t13 () (= @t12 prt))
(define @t14 () (= prt @t12))
(define @t15 () (or prt @t10))
(define @t16 () (or @t12 @t10))
(define @t17 () (= car car))
(define @t18 () (not @t3))
(define @t19 () (= @t18 car))
(define @t20 () (= car @t18))
(define @t21 () (or @t4 car))
(define @t22 () (or @t4 @t18))
(define @t23 () (or car @t4))
(define @t24 () (= clk clk))
(define @t25 () (not @t1))
(define @t26 () (= @t25 clk))
(define @t27 () (= clk @t25))
(define @t28 () (or @t4 clk))
(define @t29 () (or @t4 @t25))
(define @t30 () (or clk @t4))
(define @t31 () (or prt @t3 @t1))
(define @t32 () (or @t12 @t3 @t1))
(define @t33 () (@list true))
(define @t34 () (not @t7))
(define @t35 () (or @t7 car))
(define @t36 () (or @t7 @t18))
(define @t37 () (or car @t7))
(define @t38 () (@list @t7))
(define @t39 () (or @t5 @t3 clk))
(define @t40 () (or @t5 @t3 @t25))
(define @t41 () (or clk @t5 @t3))
(assume @p1 circuit)
(assume @p2 (not (or @t9 @t8 @t6 @t2)))
(step @p3 (= @t10 @t10) :rule refl :args (@t10))
(step @p4 (= @t11 true) :rule eq-refl :args (prt))
(step @p5 @t13 :rule bool-double-not-elim :args (prt))
(step @p6 @t11 :rule refl :args (prt))
(step @p7 (= @t14 @t11) :rule cong :premises (@p6 @p5) :args (@t14))
(step @p8 (= @t14 true) :rule trans :premises (@p7 @p4))
(step @p9 (= @t13 @t14) :rule eq-symm :args (@t12 prt))
(step @p10 (= @t13 true) :rule trans :premises (@p9 @p8))
(step @p11 @t13 :rule true_elim :premises (@p10))
(step @p12 (= @t16 @t15) :rule nary_cong :premises (@p11 @p3) :args (@t16))
(step @p13 (not @t6) :rule not_or_elim :premises (@p2) :args (2))
(step @p14 @t16 :rule not_and :premises (@p13))
(step @p15 @t15 :rule eq_resolve :premises (@p14 @p12))
(step @p16 (= @t17 true) :rule eq-refl :args (car))
(step @p17 @t19 :rule bool-double-not-elim :args (car))
(step @p18 @t17 :rule refl :args (car))
(step @p19 (= @t20 @t17) :rule cong :premises (@p18 @p17) :args (@t20))
(step @p20 (= @t20 true) :rule trans :premises (@p19 @p16))
(step @p21 (= @t19 @t20) :rule eq-symm :args (@t18 car))
(step @p22 (= @t19 true) :rule trans :premises (@p21 @p20))
(step @p23 @t19 :rule true_elim :premises (@p22))
(step @p24 (= @t4 @t4) :rule refl :args (@t4))
(step @p25 (= @t22 @t21) :rule nary_cong :premises (@p24 @p23) :args (@t22))
(step @p26 @t22 :rule cnf_or_neg :args (@t4 0))
(step @p27 @t21 :rule eq_resolve :premises (@p26 @p25))
(step @p28 @t23 :rule reordering :premises (@p27) :args (@t23))
(step @p29 (= @t24 true) :rule eq-refl :args (clk))
(step @p30 @t26 :rule bool-double-not-elim :args (clk))
(step @p31 @t24 :rule refl :args (clk))
(step @p32 (= @t27 @t24) :rule cong :premises (@p31 @p30) :args (@t27))
(step @p33 (= @t27 true) :rule trans :premises (@p32 @p29))
(step @p34 (= @t26 @t27) :rule eq-symm :args (@t25 clk))
(step @p35 (= @t26 true) :rule trans :premises (@p34 @p33))
(step @p36 @t26 :rule true_elim :premises (@p35))
(step @p37 (= @t29 @t28) :rule nary_cong :premises (@p24 @p36) :args (@t29))
(step @p38 @t29 :rule cnf_or_neg :args (@t4 1))
(step @p39 @t28 :rule eq_resolve :premises (@p38 @p37))
(step @p40 @t30 :rule reordering :premises (@p39) :args (@t30))
(step @p41 (= @t1 @t1) :rule refl :args (@t1))
(step @p42 (= @t3 @t3) :rule refl :args (@t3))
(step @p43 (= @t32 @t31) :rule nary_cong :premises (@p11 @p42 @p41) :args (@t32))
(step @p44 (not @t9) :rule not_or_elim :premises (@p2) :args (0))
(step @p45 @t32 :rule not_and :premises (@p44))
(step @p46 @t31 :rule eq_resolve :premises (@p45 @p43))
(step @p47 (or prt @t4 @t4) :rule chain_resolution :premises (@p46 @p40 @p28) :args ((@list false false) (@list clk car)))
(step @p48 (or prt @t4) :rule factoring :premises (@p47))
(step @p49 (or prt prt) :rule chain_resolution :premises (@p48 @p15) :args (@t33 (@list @t4)))
(step @p50 prt :rule factoring :premises (@p49))
(step @p51 (not @t8) :rule not_or_elim :premises (@p2) :args (1))
(step @p52 (or @t5 @t34) :rule not_and :premises (@p51))
(step @p53 @t34 :rule chain_resolution :premises (@p52 @p50) :args ((@list false) (@list prt)))
(step @p54 (= @t7 @t7) :rule refl :args (@t7))
(step @p55 (= @t36 @t35) :rule nary_cong :premises (@p54 @p23) :args (@t36))
(step @p56 @t36 :rule cnf_or_neg :args (@t7 0))
(step @p57 @t35 :rule eq_resolve :premises (@p56 @p55))
(step @p58 @t37 :rule reordering :premises (@p57) :args (@t37))
(step @p59 car :rule chain_resolution :premises (@p58 @p53) :args (@t33 @t38))
(step @p60 (or @t7 @t1) :rule cnf_or_neg :args (@t7 1))
(step @p61 @t1 :rule chain_resolution :premises (@p60 @p53) :args (@t33 @t38))
(step @p62 (= @t5 @t5) :rule refl :args (@t5))
(step @p63 (= @t40 @t39) :rule nary_cong :premises (@p62 @p42 @p36) :args (@t40))
(step @p64 (not @t2) :rule not_or_elim :premises (@p2) :args (3))
(step @p65 @t40 :rule not_and :premises (@p64))
(step @p66 @t39 :rule eq_resolve :premises (@p65 @p63))
(step @p67 @t41 :rule reordering :premises (@p66) :args (@t41))
(step @p68 false :rule chain_resolution :premises (@p67 @p61 @p59 @p50) :args ((@list true false false) (@list clk car prt)))
