\documentclass[lualatex, 12pt, handout]{beamer}
\usetheme{Arguelles}

\usepackage{xcolor}
\usepackage{xcolor-material}
\usepackage{ebproof}
\usepackage{unicode-math-input}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{amssymb}

\usepackage{emoji}
\usepackage{listings}
\usepackage{array}
% \newfontfamily\Alegreya{Alegreya-Regular.otf}[
%   BoldFont=Alegreya-Bold.otf,
%   ItalicFont=Alegreya-Italic.otf,
%   BoldItalicFont=Alegreya-BoldItalic.otf]

\title{Eunoia to LambdaPi}
\author{Ciar√°n Dunne and Guillaume Burel}
\institute{ENS Paris-Saclay, INRIA}

\input{talk.macros}


\begin{document}

\frame[plain]{\titlepage}

\section{Background}

\begin{frame}[fragile, plain]{Background}
	\begin{itemize}
		\item<+-> \alert{Satisfiability modulo theories} (SMT)
		      is an area of automated reasoning aimed at
		      developing tools for deciding the satisfiability
		      of formulas within a curated selection of
		      first-order mathematical theories.
		      %
		\item<+-> \alert{SMT-LIB} (v2.7) is a standardized
		      formal language for satisfiability problems
		      and theory documentation.
	\end{itemize}
	%
	\begin{uncoverenv}<+->
		\exxample
		Find $x,y ‚àà ‚Ñ§$ such that $(x + 2y) = 20$ and $(x - y) = 2$.
		\begin{lstlisting}
(set-logic QF_LIA)
(declare-const x Int)
(declare-const y Int)
(assert (= (+ x (* 2 y)) 20))
(assert (= (- x y) 2))
(check-sat)
(exit)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile, plain]
	\begin{uncoverenv}<+->
		\exxample
		The example problem is \alert{satisfiable}.
		Hence, \texttt{cvc5} can return a \alert{solution}
		assigning concrete values to free variables.
	\end{uncoverenv}
	%
	\begin{uncoverenv}<+->
		\begin{lstlisting}
(set-logic QF_LIA)
(set-option :produce-models true)
(declare-const x Int)
(declare-const y Int)
(assert (= (+ x (* 2 y)) 20))
(assert (= (- x y) 2))
...\end{lstlisting}
		\hrule
		\begin{lstlisting}
sat
(
  (define-fun x () Int 8)
  (define-fun y () Int 6)
)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile, plain]
	\begin{uncoverenv}<+->
		\exxample
		The following problem is \alert{unsatisfiable}.
		In this case, \texttt{cvc5} can provide a \alert{proof} demonstrating this.
	\end{uncoverenv}
	\begin{uncoverenv}<+->
		\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(set-logic QF_UF)
(set-option :produce-proofs true)
(declare-const p Bool)
(assert (and p (not p)))
(check-sat)
(get-proof)
(exit)\end{lstlisting}
		\hrule
		\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
unsat
(declare-fun p () Bool)
(assume @p1 (and p (not p)))
(step @p2 :rule and_elim :premises (@p1) :args (1))
(step @p3 :rule and_elim :premises (@p1) :args (0))
(step @p4 false :rule contra :premises (@p3 @p2))\end{lstlisting}
	\end{uncoverenv}
	\begin{uncoverenv}<+->
		\textbf{What is the formal meaning of this proof?}
	\end{uncoverenv}
	\\
	\begin{uncoverenv}<+->
		\textbf{In general, what rules may be used in a proof?}
	\end{uncoverenv}
\end{frame}


\begin{frame}[fragile, plain]
	% tikz diagram here for the dir-tree of eo/cpc/...
	% tikz diagram for proof output by cvc5, checked by ethos.
	\begin{itemize}
		\item<+-> The \alert{co-operating proof calculus} (CPC)
		      is \texttt{cvc5}'s proof system.
		      \begin{itemize}
			      \item[\emoji{angel}]<+-> faithful to the internal reasoning of \texttt{cvc5}.
			      \item[\emoji{elephant}]<+-> not small (${>}\ 100$ inference rules).
			      \item[\emoji{puzzle-piece}] some rules take arguments, some have side-conditions.
		      \end{itemize}
	\end{itemize}
	%
	\begin{uncoverenv}<+->
		\exxample A CPC rule for elimination on $n$-ary conjunctions,
		where $œÜ_1 \ldots œÜ_n$ are formulas and $i ‚àà ‚Ñï$.
		\[
			\begin{prooftree}
				\hypo{(œÜ_1 ‚àß \ldots ‚àß œÜ_n) ‚à£ i}
				\infer1{œÜ_i}
			\end{prooftree}
		\]
	\end{uncoverenv}
	\\
	\begin{uncoverenv}<+->
		\textbf{How and where are these rules specified?}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile, plain]{Eunoia and Ethos}
	\begin{itemize}
		\item<+->
		      \alert{Eunoia} is an emerging \emph{logical framework} aimed at
		      formalizing the proof systems used by SMT solvers.
		      \begin{itemize}
			      \item[\emoji{flag-united-states}]<+-> development led by Andrew Reynolds, at University of Iowa.
			      \item[\emoji{ghost}]<+-> the `spiritual successor' of the \alert{Alethe} proof format.
			      \item[\emoji{scroll}]<+-> covers theory signatures \& proof scripts.
			      \item[\emoji{check-mark}]<+-> paired with the \alert{Ethos} checker.
		      \end{itemize}

		\item<+-> Extends SMT-LIB by adding:
		      \begin{itemize}
			      \item<+->(dependent) types, parametric polymorphism
			      \item<+->`programs' (i.e., constants with rewrite rules)
			      \item<+->inference rules, commands for building proofs
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile, plain]
	% tikz diagram here for the dir-tree of eo/cpc/...
	% tikz diagram for proof output by cvc5, checked by ethos.
	\begin{itemize}
		\item<+-> The \alert{co-operating proof calculus}
		      (i.e., CPC, the proof system of \texttt{cvc5})
		      is formalized as a Eunoia signature $Œ£_{\cpc}$.

		\item<+-> Proofs produced by \texttt{cvc5} are
		      Eunoia proof scripts that exclusively use
		      the inference rules from $Œ£_{\cpc}$.
	\end{itemize}
\end{frame}

\begin{frame}[fragile, plain]{LambdaPi}
	\begin{itemize}
		\item<+-> Logical framework based
		      on the \emph{$ŒªŒ†$-calculus modulo rewriting}.
		      \begin{itemize}
			      \item[\emoji{flag-france}]<+-> development led by Fr√©d√©ric Blanqui, INRIA Paris-Saclay
			      \item[\emoji{locked}]<+-> small and fast, trusted code base.
			      \item[\emoji{robot}]<+-> interactive theorem proving via LSP!
		      \end{itemize}

		\item<+-> Primarily focused on proof assistant \alert{interoperability}.
	\end{itemize}
	\vspace{2mm}
	\begin{figure}
		\centering
		\begin{tikzpicture}[scale=0.8]
			\path (0,0) node (lp) {{\large\LambdaPi}}
			(5,0) node (isa) {\small\sysname{Isabelle}}
			(3,-2) node (agda) {\small\sysname{Agda}}
			% (0,2) node (ze) {Zenon \& ArchSAT}
			(3,2) node (hol) {\small\sysname{HOL}}
			(0,-2) node (pvs) {\small\sysname{PVS}}
			(-3,-2) node (k) {\small\sysname{$\mathbb{K}$-framework}}
			(-5,0) node (mat) {\small\sysname{Matita}}
			(0,2) node (coq) {\small\sysname{Rocq}}
			(-3,2) node (lean) {\small\sysname{Lean}}
			% (0,2) node [draw, dashed, purple] (smt) {\color{purple}\textbf{SMT}}
			;
			% \draw[->,red, thick] (smt) -- (lp) node[midway,sloped,above]
			% {\footnotesize{Carcara}};
			\draw[->] (lean) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{lean2dk}};
			\draw[->] (isa) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{isabelle\_dk}};
			\draw[->] (agda) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{agda2dk}};
			% \draw[<->] (ze) -- (lp) node[midway,sloped,above] {};
			\draw[<->] (hol) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{hol2dk}};
			\draw[<->] (mat) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{Krajono}};
			\draw[->] (pvs) -- (lp);
			\draw[->] (k) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{KaMeLo}};
			\draw[<->] (coq) -- (lp)  node[midway,sloped,above] {\scriptsize\toolname{vodk}};
		\end{tikzpicture}
		\label{fig:interop}
	\end{figure}
\end{frame}

\begin{frame}[fragile, plain]{Why Eunoia?}
	\begin{itemize}
		\item<+-> What about Alethe?
		      \begin{itemize}
			      \item<+-> inference rules only exist \emph{in papyro}.
			      \item<+-> missing details needed for reconstruction.
			      \item<+->
			            \textbf{Coltellacci and Merz}: extend \alert{Carcara}
			            to support LambdaPi output.
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{}
	\begin{itemize}
		\item<+-> \emph{\color{oc-green-9}Goal:}
		      Design a translation procedure $T$ such that:
		      \begin{itemize}
			      \item<+-> if $Œ£$ is a Eunoia signature implementing some \alert{logic} $L$,
			      \item<+-> then $T(Œ£)$ is a LambdaPi signature also implementing $L$.
			            \\[2mm]
		      \end{itemize}

		\item<+-> Thus, if $Œ†$ is a valid Eunoia \alert{proof script} depending on $Œ£$,
		      then $T(Œ†)$ should be \alert{well-typed} wrt. $T(Œ£)$.
	\end{itemize}
\end{frame}

\section{Syntax}



\section{Semantics}


\section{Proofs \& Lambdapi}






% TODO.
% smt-lib 3 proposal.
% - dependent types, polymorphism
% - commands
% chad browns notes.
% Eunoia, Ethos.

% SMT-LIB 3 in CC
% proof-irrelevant semantics of CC

% dekuti encoding of CC.
% future proofing:
% translating smt3 concrete syntax into CC does the same for SMT 2.6 and for SMT 2.7.


% some argument about why even though we have a much more expressive logic,
% SMT solvers will only still support a small fragment of it.
% regardless, it is very important for many reasons to

\end{document}



% \begin{frame}[fragile, plain]
% 	\exxample Proof script generated by \textsc{cvc5}.
% 	\begin{lstlisting}
% (declare-const =
%   (-> (! Type :var T :implicit) T T Bool))
% (declare-rule symm ((T Type) (t T) (s T))
%     :premises ((= t s))
%     :conclusion (= s t)
% )
% (declare-type Int ())
% (declare-const a Int)
% (declare-const b Int)
% (assume @p0 (= a b))
% (step @p1 (= b a) :rule symm :premises (@p0))\end{lstlisting}
% 	%
% 	Declaring rules requires adding $\PROP$-level functions, e.g.;
% 	%
% 	$$\msf{symm} :
% 		(\pii {T : \TYPE,\,t : T,\,s : T} {\lift{t = s} ‚Üí \lift{s = t}})$$
% \end{frame}

% \begin{frame}
% 	\begin{itemize}
% 		\item<+-> \emph{\color{oc-green-9}Goal:}
% 		      Implement a translation from SMT-LIB v3 and Eunoia to
% 		      an OCaml representation of CC.
% 		\item<+-> Use axioms of Theory $ùïå$ for encoding CC in Lambdapi.
% 		      %
% 		      $$
% 			      \begin{array}{l@{\quad}l}
% 				      \eval{\TYPE}_{\lp} ‚â° \tt{Set}
% 				       &
% 				      \eval{\lam {x : t_1} {t_2}}_{\lp} ‚â° \lam {x' : \eval{t_1}} {\eval{t_2}}
% 				      \\
% 				      \eval{\PROP}_{\lp} ‚â° \tt{Prop}
% 				       &
% 				      \eval{\pii {x : t_1}{t_2}}_{\lp} ‚â° \eval{t_1}_{\lp} \leadsto^d \eval{t_2}_{\lp}
% 			      \end{array}
% 		      $$
% 	\end{itemize}
% \end{frame}
