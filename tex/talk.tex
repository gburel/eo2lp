\documentclass[lualatex, compress, 12pt, handout]{beamer}
\usetheme{Arguelles}

% \usepackage{stix}
\usepackage{xcolor}
\usepackage{xcolor-material}
\usepackage{ebproof}
\usepackage{unicode-math-input}
\usepackage{MnSymbol}
% \usepackage{fdsymbol}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{amssymb}

\usepackage{emoji}
\usepackage{listings}
\usepackage{array}
% \newfontfamily\Alegreya{Alegreya-Regular.otf}[
%   BoldFont=Alegreya-Bold.otf,
%   ItalicFont=Alegreya-Italic.otf,
%   BoldItalicFont=Alegreya-BoldItalic.otf]

\title{Eunoia to LambdaPi}
\author{Ciar√°n Dunne and Guillaume Burel}
\institute{ENS Paris-Saclay, INRIA}

\input{talk.macros}


\begin{document}

\frame[plain]{\titlepage}

\section{Background}

\begin{frame}[fragile, plain]{Background}
	\begin{itemize}
		\item<+-> \alert{Satisfiability modulo theories} (SMT)
		      is an area of automated reasoning aimed at
		      developing tools for deciding the satisfiability
		      of formulas within a curated selection of
		      first-order mathematical theories.
		      %
		\item<+-> \alert{SMT-LIB} (v2.7) is a standardized
		      formal language for satisfiability problems
		      and theory documentation.
	\end{itemize}
	%
	\begin{uncoverenv}<+->
		\exxample
		Find $x,y ‚àà ‚Ñ§$ such that $(x + 2y) = 20$ and $(x - y) = 2$.
		\begin{lstlisting}
(set-logic QF_LIA)
(declare-const x Int)
(declare-const y Int)
(assert (= (+ x (* 2 y)) 20))
(assert (= (- x y) 2))
(check-sat)
(exit)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile, plain]
	\begin{uncoverenv}<+->
		\exxample
		The example problem is \alert{satisfiable}.
		Hence, \texttt{cvc5} can return a \alert{solution}
		assigning concrete values to free variables.
	\end{uncoverenv}
	%
	\begin{uncoverenv}<+->
		\begin{lstlisting}
(set-logic QF_LIA)
(set-option :produce-models true)
(declare-const x Int)
(declare-const y Int)
(assert (= (+ x (* 2 y)) 20))
(assert (= (- x y) 2))
(check-sat)
(exit)
\end{lstlisting}
		\hrule
		\begin{lstlisting}
sat
(
  (define-fun x () Int 8)
  (define-fun y () Int 6)
)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile, plain]
	\begin{uncoverenv}<+->
		\exxample
		The following problem is \alert{unsatisfiable}.
		In this case, \texttt{cvc5} can provide a \alert{proof} demonstrating this.
	\end{uncoverenv}
	\begin{uncoverenv}<+->
		\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(set-logic QF_UF)
(set-option :produce-proofs true)
(declare-const p Bool)
(assert (and p (not p)))
(check-sat)
(get-proof)
(exit)\end{lstlisting}
		\hrule
		\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
unsat
(declare-fun p () Bool)
(assume @p1 (and p (not p)))
(step @p2 :rule and_elim :premises (@p1) :args (1))
(step @p3 :rule and_elim :premises (@p1) :args (0))
(step @p4 false :rule contra :premises (@p3 @p2))\end{lstlisting}
	\end{uncoverenv}
	\begin{uncoverenv}<+->
		\textbf{What is the formal meaning of this proof?}
	\end{uncoverenv}
	\\
	\begin{uncoverenv}<+->
		\textbf{In general, what rules may be used in a proof?}
	\end{uncoverenv}
\end{frame}


\begin{frame}[fragile, plain]
	% tikz diagram here for the dir-tree of eo/cpc/...
	% tikz diagram for proof output by cvc5, checked by ethos.
	\begin{itemize}
		\item<+-> The \alert{co-operating proof calculus} (CPC)
		      is \texttt{cvc5}'s proof system.
		      \begin{itemize}
			      \item[\emoji{angel}]<+-> faithful to the internal reasoning of \texttt{cvc5}.
			      \item[\emoji{elephant}]<+-> not small (${>}\ 100$ inference rules).
			      \item[\emoji{puzzle-piece}] some rules take arguments, some have side-conditions.
		      \end{itemize}
	\end{itemize}
	%
	\begin{uncoverenv}<+->
		\exxample A CPC rule for elimination on $n$-ary conjunctions,
		where $œÜ_1 \ldots œÜ_n$ are formulas and $i ‚àà ‚Ñï$.
		\[
			\begin{prooftree}
				\hypo{(œÜ_1 ‚àß \ldots ‚àß œÜ_n) ‚à£ i}
				\infer1{œÜ_i}
			\end{prooftree}
		\]
	\end{uncoverenv}
	\\
	\begin{uncoverenv}<+->
		\textbf{How and where are these rules specified?}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile, plain]{Eunoia and Ethos}
	\begin{itemize}
		\item<+->
		      \alert{Eunoia} is an emerging \emph{logical framework} aimed at
		      formalizing the proof systems used by SMT solvers.
		      \begin{itemize}
			      \item[\emoji{flag-united-states}]<+-> development led by Andrew Reynolds, at University of Iowa.
			      \item[\emoji{ghost}]<+-> the `spiritual successor' of the \alert{Alethe} proof format.
			      \item[\emoji{scroll}]<+-> covers theory signatures \& proof scripts.
			      \item[\emoji{check-mark}]<+-> paired with the \alert{Ethos} checker.
		      \end{itemize}

		\item<+-> Extends SMT-LIB by adding:
		      \begin{itemize}
			      \item<+->(dependent) types, parametric polymorphism
			      \item<+->`programs' (i.e., constants with rewrite rules)
			      \item<+->inference rules, commands for building proofs
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}[fragile, plain]
	% tikz diagram here for the dir-tree of eo/cpc/...
	% tikz diagram for proof output by cvc5, checked by ethos.
	\begin{itemize}
		\item<+-> The \alert{co-operating proof calculus}
		      (i.e., CPC, the proof system of \texttt{cvc5})
		      is formalized as a Eunoia signature $Œ£_{\cpc}$.

		\item<+-> Proofs produced by \texttt{cvc5} are
		      Eunoia proof scripts that exclusively use
		      the inference rules from $Œ£_{\cpc}$.
	\end{itemize}
\end{frame}

\begin{frame}[fragile, plain]{LambdaPi}
	\begin{itemize}
		\item<+-> Logical framework based
		      on the \emph{$ŒªŒ†$-calculus modulo rewriting}.
		      \begin{itemize}
			      \item[\emoji{flag-france}]<+-> development led by Fr√©d√©ric Blanqui, INRIA Paris-Saclay
			      \item[\emoji{locked}]<+-> small and fast, trusted code base.
			      \item[\emoji{robot}]<+-> interactive theorem proving via LSP!
		      \end{itemize}

		\item<+-> Primarily focused on proof assistant \alert{interoperability}.
	\end{itemize}
	\vspace{2mm}
	\begin{figure}
		\centering
		\begin{tikzpicture}[scale=0.8]
			\path (0,0) node (lp) {{\large\LambdaPi}}
			(5,0) node (isa) {\small\sysname{Isabelle}}
			(3,-2) node (agda) {\small\sysname{Agda}}
			% (0,2) node (ze) {Zenon \& ArchSAT}
			(3,2) node (hol) {\small\sysname{HOL}}
			(0,-2) node (pvs) {\small\sysname{PVS}}
			(-3,-2) node (k) {\small\sysname{$\mathbb{K}$-framework}}
			(-5,0) node (mat) {\small\sysname{Matita}}
			(0,2) node (coq) {\small\sysname{Rocq}}
			(-3,2) node (lean) {\small\sysname{Lean}}
			% (0,2) node [draw, dashed, purple] (smt) {\color{purple}\textbf{SMT}}
			;
			% \draw[->,red, thick] (smt) -- (lp) node[midway,sloped,above]
			% {\footnotesize{Carcara}};
			\draw[->] (lean) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{lean2dk}};
			\draw[->] (isa) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{isabelle\_dk}};
			\draw[->] (agda) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{agda2dk}};
			% \draw[<->] (ze) -- (lp) node[midway,sloped,above] {};
			\draw[<->] (hol) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{hol2dk}};
			\draw[<->] (mat) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{Krajono}};
			\draw[->] (pvs) -- (lp);
			\draw[->] (k) -- (lp) node[midway,sloped,above] {\scriptsize\toolname{KaMeLo}};
			\draw[<->] (coq) -- (lp)  node[midway,sloped,above] {\scriptsize\toolname{vodk}};
		\end{tikzpicture}
		\label{fig:interop}
	\end{figure}
\end{frame}

\begin{frame}[fragile, plain]{Why Eunoia?}
	\begin{itemize}
		\item<+-> What about Alethe?
		      \begin{itemize}
			      \item<+-> inference rules only exist \emph{in papyro}.
			      \item<+-> missing details needed for reconstruction.
			      \item<+->
			            \textbf{Coltellacci and Merz}: extend \alert{Carcara}
			            to support LambdaPi output.
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{}
	\begin{itemize}
		\item<+-> \emph{\color{oc-green-9}Goal:}
		      Design a translation procedure $T$ such that:
		      \begin{itemize}
			      \item<+-> if $Œ£$ is a Eunoia signature implementing some \alert{logic} $L$,
			      \item<+-> then $T(Œ£)$ is a LambdaPi signature also implementing $L$.
			            \\[2mm]
		      \end{itemize}

		\item<+-> Thus, if $Œ†$ is a valid Eunoia \alert{proof script} depending on $Œ£$,
		      then $T(Œ†)$ should be \alert{well-typed} wrt. $T(Œ£)$.
	\end{itemize}
\end{frame}

\section{Eunoia}

\begin{frame}
	\begin{itemize}
		\item<+-> Fix a set of \alert{symbols} $ùíÆ$, and let $s ‚àà ùíÆ$.
		\item<+-> Define $\mbf{eo}$ as the set of Eunoia \alert{expressions} thus:
		      $$
			      \begin{array}{l@{\ }c@{\ }l@{\quad}l}
				      e ‚àà \mbf{eo} & ‚©¥ & s                             & \mcomment{(symbol)}      \\
				                   & ‚à£ & \paren{{s}\ e_1\ \ldots\ e_n} & \mcomment{(application)}
			      \end{array}
		      $$
		\item<+-> In general, expressions are either:
		      \begin{itemize}
			      \item<+-> \alert{terms} (e.g., \mtt{true}, \mtt{false})
			      \item<+-> \alert{types}
			            (e.g.,
			            \mtt{Bool},
			            \paren{\mtt{->}\ \mtt{Bool}\ \mtt{Bool}}
			            )
			      \item<+-> \alert{kinds}
			            (e.g., \mtt{Type}, \paren{\mtt{->}\ \mtt{Type}\ \mtt{Type}})
		      \end{itemize}
	\end{itemize}
\end{frame}


\begin{frame}[fragile]
	Eunoia has \alert{constant declarations} of the form:
	$$\paren{\mtt{declare-const}\ s\ e\ \maybe{Œ±}}$$
	where $Œ±$ is a \alert{constant attribute}. i.e.,
	$$
		\begin{array}{l@{\ }c@{\ }l}
			Œ± ‚àà \mbf{attr_c} & ‚©¥   & \mtt{:right-assoc} ‚à£ \mtt{:right-assoc-nil}\some{t}                        \\
			                 & {‚à£} & \mtt{:left-assoc} ‚à£ \mtt{:left-assoc-nil}\some{t}                          \\
			                 & {‚à£} & \mtt{:chainable}\some{s} ‚à£ \mtt{:pairwise}\some{s} ‚à£ \mtt{:binder}\some{s}
			\\[2mm]
		\end{array}
	$$

	\begin{uncoverenv}<+->
		\exxample Declare \mtt{and} right-associative,
		with \emph{nil terminator} \mtt{true}.
		\begin{lstlisting}
(declare-const and (-> Bool Bool Bool)
  :right-assoc-nil true
)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile]
	\begin{uncoverenv}<+->
		Hereinafter, applications of \mtt{and} are elaborated thus:\\
		$$\text{\smt{(and p q r)}}
			‚üπ \text{\smt{(and p (and q (and r true)))}}$$
		% tikz diagram of
		%   `(and p q r)`
		% elaborating to
		%   `(and p (and q (and r true)))`
	\end{uncoverenv}
\end{frame}



\begin{frame}[fragile]
	We can also declare \alert{parameterized constants}:
	$$ \paren{\mtt{declare-parameterized-const}
		\ s
		\  \paren{\plur œÅ n}
		\  {e}
		\ \maybe{Œ±}
		} $$
	\begin{uncoverenv}<+->
		where $œÅ$ is a \alert{(typed) parameter}. i.e.,
		$$
			\begin{array}{l@{\ }c@{\ }l}
				œÅ ‚àà \mbf{param}  & ‚©¥ & \paren{s\ t\ \maybe{ŒΩ}}       \\
				ŒΩ ‚àà \mbf{attr_v} & ‚©¥ & \mtt{:implicit} ‚à£ \mtt{:list}
			\end{array}
		$$

	\end{uncoverenv}
	\begin{uncoverenv}<+->
		\exxample Constant declaration for equality.
		\begin{lstlisting}
(declare-parameterized-const =
  ((A Type :implicit)) (-> A A Bool)
  :chainable and
)\end{lstlisting}
	\end{uncoverenv}
\end{frame}


\begin{frame}
	Eunoia can \alert{define} symbols with macro behaviour:
	$$\paren{\mtt{define}
			\ s
			\  \paren{\plur œÅ n}
			\ e
			\ \maybe{\mtt{:type}\ t}
		}$$
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> Eunoia has literals.
	\end{itemize}
\end{frame}


\begin{frame}
	\begin{itemize}
		\item<+-> Eunoia has type declarations.
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> Eunoia has programs.
	\end{itemize}
\end{frame}


\begin{frame}
	\begin{itemize}
		\item<+-> Eunoia has programs.
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> Eunoia has built-in programs.
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> Eunoia has rule declarations.
	\end{itemize}
\end{frame}
% \begin{frame}
% 	In general, expressions are either \alert{terms}, \alert{types}, or \alert{kinds}.
% 	\begin{itemize}
% 		\item<+-> Fix a domain $ùíü$ of \alert{individuals}.
% 		      \begin{itemize}
% 			      \item<+-> each term denotes some $x ‚àà ùíü$, or some function $f ‚àà ùíü ‚áÄ ùíü$.
% 			      \item<+-> e.g., $\mtt{true}$ and $\mtt{false}$ are terms denoting $\mbf{1}$ and $\mbf{0}$ resp.
% 		      \end{itemize}


% 		      partitioned by $B_1 \ldots B_n$,
% 		      $$ ùíü = B_1 ‚à™ \ldots ‚à™ B_n $$
% 		      \begin{itemize}
% 			      \item<+-> each term denotes either an individual or a function between individuals,
% 			      \item<+-> e.g., $\mtt{Bool}$ is a base type denoting $\{\mbf{1},\mbf{0}\}$,
% 		      \end{itemize}
% 		\item<+-> Let $ùíØ$ be the domain for \alert{types}, where:
% 		      $$ œÑ ‚àà ùíØ ‚©¥ B_i ‚à£ (œÑ_1 ‚Üí œÑ_2)$$
% 		\item<+-> Let $ùí¶$ be the domain for \alert{kinds}, where:
% 		      $$ Œ∫ ‚àà ùí¶ ‚©¥ ùíØ ‚à£ (Œ∫_1 ‚Üí Œ∫_2) $$

% 	\end{itemize}


% \begin{itemize}
% 	\item<+-> $\paren{\mtt{->}\ \mtt{Bool}\ \mtt{Bool}}$ denotes the function space $\{\mbf{1},\mbf{0}\} ‚Üí \{\mbf{1},\mbf{0}\}$.
% \end{itemize}
% \begin{itemize}
% 	\item<+-> $\mtt{Type}$ is a kind, denoting the set of all types.
% 	\item<+-> $\paren{\mtt{->}\ \mtt{Type}\ \mtt{Type}}$ is a kind, denoting the set of type constructors.
% \end{itemize}



% \end{uncoverenv}

\section{LambdaPi}

% switch to purple colour here

\begin{frame}
	\begin{itemize}
		\item<+-> LambdaPi terms are those of the $ŒªŒ†$-calculus.
		      %
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> We can define symbols.
		      %
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> We can define rewrite rules.
		      %
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> We encode types and terms with $\mbf{Set}$ and $\mbf{El}$.
		      %
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> We encode logic and proofs with $\mbf{Prop}$ and $\mbf{Prf}$.
		      %
	\end{itemize}
\end{frame}

\section{Translation}

\newcommand{\tra}[1]{\llbracket\,#1\,\rrbracket}
\newcommand{\ki}[1]{{\tra{#1}}_{\mbf{ki}}}
\newcommand{\ty}[1]{{\tra{#1}}_{\mbf{ty}}}
\newcommand{\rawapp}[2]{\paren{\mtt{\_}\ {#1}\ {#2}}}

\begin{frame}
	Track \alert{attributes} of symbols during translation:
	$$Œ≥ : ùíÆ ‚áÄ (\mbf{attr_c} ‚à™ \mbf{attr_v})$$
	Expressions are first elaborated with $\mbf{elab}_{Œ≥} : \mbf{eo} ‚Üí \mbf{eo}$.
	\begin{itemize}
		\item<+-> Eunoia has a built-in symbol $\mtt{\_}$ for (higher-order) application.

		\item<+-> The \alert{default} elaboration strategy is to left-fold:
		      $$
			      \begin{array}{r@{\ =\ }l}
				      \mbf{elab}_{Œ≥}\paren{s\ e_1\ \ldots\ e_n}
				       & ((s ‚àó e_1) ‚àó \ldots ‚àó e_n)
				      \\
				       & \paren{\mtt{\_}\ \paren{\ldots\paren{\mtt{\_}\ s\ e_1}\ldots}\ \ e_n}
			      \end{array}
		      $$

		\item<+-> In general, strategy depends on attributes, e.g.,
		      $$ \mbf{elab}_{Œ≥}\paren{\mtt{and}\ p\ q \ r} =
			      (\mtt{and}\ p ‚àó (\mtt{and}\ q ‚àó (\mtt{and}\ r ‚àó \mtt{true})))
		      $$

		      % $$
		      %  \begin{array}{l@{\ }c@{\ }l}
		      %   Œ± ‚àà \mbf{attr_c} & ‚©¥   & \mtt{:right-assoc} ‚à£ \mtt{:right-assoc-nil}\some{t}                        \\
		      %                    & {‚à£} & \mtt{:left-assoc} ‚à£ \mtt{:left-assoc-nil}\some{t}                          \\
		      %                    & {‚à£} & \mtt{:chainable}\some{s} ‚à£ \mtt{:pairwise}\some{s} ‚à£ \mtt{:binder}\some{s}
		      %   \\[2mm]
		      %   ŒΩ ‚àà \mbf{attr_v} & ‚©¥   & \mtt{:implicit} ‚à£ \mtt{:list}
		      %  \end{array}
		      % $$
	\end{itemize}
\end{frame}

% \begin{frame}
% 	Track target \alert{universe} of symbols by $Œº : ùíÆ ‚áÄ \{ \mbf{tm}, \mbf{ty}, \mbf{ki} \}$,
% 	e.g., $$ Œº(\mtt{Bool}) = \mbf{ty} \qquad Œº(\mtt{Type}) = \mbf{ki} $$
% 	%
% 	\begin{uncoverenv}<+->%
% 		Extend to Eunoia expressions thus:
% 		$$
% 			\begin{array}{r@{\ =\ }l}
% 				Œº\paren{\mtt{->}\ {\plur e n}} &
% 				\begin{dcases}
% 					\ \mbf{ki} & \text{if $e_n = \mtt{Type}$,} \\
% 					\ \mbf{ty} & \text{otherwise}
% 				\end{dcases}
% 				\\[5mm]
% 				Œº\paren{s\ \plur e n}          &
% 				Œº(s)
% 			\end{array}
% 		$$
% 	\end{uncoverenv}
% \end{frame}

\begin{frame}
	\begin{uncoverenv}<+->
		Translate \alert{kinds} into LambdaPi types via
		${\tra\cdot}_{\mbf{ki}} : \mbf{eo} ‚Üí \mbf{lp}$;
		$$
			\begin{array}{r@{\ =\ }l}
				\ki{\mtt{Type}}                    & \mtt{Set} \\[3mm]
				% \begin{dcases}
				% 	\ \mtt{Set} & \text{if}\ $s = $,
				% 	\\
				% 	\ \ty{s}    & \text{otherwise}
				% \end{dcases}

				%
				\ki{\paren{\mtt{->}\ {\plur e n}}} &
				\ki{e_1} ‚Üí \ldots ‚Üí \ki{e_n}                   \\[3mm]
				% \begin{dcases}
				% 	\ \mtt{Set} & \text{if}\ $s = $,
				% 	\\
				% 	\ \ty{s}    & \text{otherwise}
				% \end{dcases}

				%
				\ki{e'}                            &
				\mtt{El}\ \ty{e'}
			\end{array}
		$$
		\begin{uncoverenv}<+->%
			\exxample Consider the translation of the following Eunoia kind.
			$$
				\ki{\paren{\mtt{->}\ \mtt{Int}\ \mtt{Type}}} =
				\left(\mtt{El}\ \ty{\mtt{Int}} ‚Üí \mtt{Set}\right)
			$$
		\end{uncoverenv}
		% where $u_i ‚âî Œº(e_i)$ for each $i ‚àà \{1 \ldots n\}$.
	\end{uncoverenv}
\end{frame}

\begin{frame}
	\begin{uncoverenv}<+->%
		Type declarations are translated thus:
		$$
			\begin{array}{c}
				\paren{\mtt{declare-type}\ t\ \paren{\plur e n}}
				\\[2mm]
				‚áì
				\\[2mm]
				\mtt{symbol}\ {t} : \ki{e_1} ‚Üí \ldots ‚Üí \ki{e_n} ‚Üí \mtt{Set};
			\end{array}
		$$
	\end{uncoverenv}
	\\
	\begin{uncoverenv}<+->%
		\exxample
	\end{uncoverenv}
\end{frame}


\begin{frame}
	\begin{uncoverenv}<+->
		Translate \alert{types} to LambdaPi sets via
		${\tra\cdot}_{\mbf{ty}} : \mbf{eo} ‚Üí \mbf{lp}$;
		$$
			\begin{array}{r@{\ =\ }l}
				% \begin{dcases}
				% 	\ \mtt{Set} & \text{if}\ $s = $,
				% 	\\
				% 	\ \ty{s}    & \text{otherwise}
				% \end{dcases}

				%
				\ty{\paren{\mtt{->}\ {\plur e n}}} &
				\ty{e_1} \leadsto \ldots \leadsto \ty{e_n}
			\end{array}
		$$

	\end{uncoverenv}
\end{frame}


\begin{frame}
\end{frame}


\begin{frame}
	\begin{itemize}
		\item<+-> Track \alert{attributes} of symbols during translation:
		      % $$Œ≥ : ùíÆ ‚Üí (\mbf{attr_c} ‚à™ \mbf{attr_v})$$

		\item<+-> Terms are translated wrt.
		      %
	\end{itemize}
\end{frame}

\begin{frame}
	\begin{itemize}
		\item<+-> Term translation function $\msf{tr}_Œ≥ : \mbf{eo} ‚Üí \mbf{lp}$.

	\end{itemize}
\end{frame}


\section{Results}

\subsection{Translating CPC}

\subsection{Translating Rodin}






% TODO.
% smt-lib 3 proposal.
% - dependent types, polymorphism
% - commands
% chad browns notes.
% Eunoia, Ethos.

% SMT-LIB 3 in CC
% proof-irrelevant semantics of CC

% dekuti encoding of CC.
% future proofing:
% translating smt3 concrete syntax into CC does the same for SMT 2.6 and for SMT 2.7.


% some argument about why even though we have a much more expressive logic,
% SMT solvers will only still support a small fragment of it.
% regardless, it is very important for many reasons to

\end{document}



% \begin{frame}[fragile, plain]
% 	\exxample Proof script generated by \textsc{cvc5}.
% 	\begin{lstlisting}
% (declare-const =
%   (-> (! Type :var T :implicit) T T Bool))
% (declare-rule symm ((T Type) (t T) (s T))
%     :premises ((= t s))
%     :conclusion (= s t)
% )
% (declare-type Int ())
% (declare-const a Int)
% (declare-const b Int)
% (assume @p0 (= a b))
% (step @p1 (= b a) :rule symm :premises (@p0))\end{lstlisting}
% 	%
% 	Declaring rules requires adding $\PROP$-level functions, e.g.;
% 	%
% 	$$\msf{symm} :
% 		(\pii {T : \TYPE,\,t : T,\,s : T} {\lift{t = s} ‚Üí \lift{s = t}})$$
% \end{frame}

% \begin{frame}
% 	\begin{itemize}
% 		\item<+-> \emph{\color{oc-green-9}Goal:}
% 		      Implement a translation from SMT-LIB v3 and Eunoia to
% 		      an OCaml representation of CC.
% 		\item<+-> Use axioms of Theory $ùïå$ for encoding CC in Lambdapi.
% 		      %
% 		      $$
% 			      \begin{array}{l@{\quad}l}
% 				      \eval{\TYPE}_{\lp} ‚â° \tt{Set}
% 				       &
% 				      \eval{\lam {x : t_1} {t_2}}_{\lp} ‚â° \lam {x' : \eval{t_1}} {\eval{t_2}}
% 				      \\
% 				      \eval{\PROP}_{\lp} ‚â° \tt{Prop}
% 				       &
% 				      \eval{\pii {x : t_1}{t_2}}_{\lp} ‚â° \eval{t_1}_{\lp} \leadsto^d \eval{t_2}_{\lp}
% 			      \end{array}
% 		      $$
% 	\end{itemize}
% \end{frame}
