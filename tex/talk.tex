\documentclass[lualatex, 12pt, handout]{beamer}
\usetheme{Arguelles}

\usepackage{xcolor}
\usepackage{ebproof}
\usepackage{unicode-math-input}
\usepackage{MnSymbol}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{amssymb}

\usepackage{emoji}
\usepackage{listings}
\usepackage{array}
% \newfontfamily\Alegreya{Alegreya-Regular.otf}[
%   BoldFont=Alegreya-Bold.otf,
%   ItalicFont=Alegreya-Italic.otf,
%   BoldItalicFont=Alegreya-BoldItalic.otf]

\title{Eunoia to LambdaPi}
\author{Ciar√°n Dunne and Guillaume Burel}
\institute{ENS Paris-Saclay, INRIA}

\input{talk.macros}


\begin{document}

\frame[plain]{\titlepage}

\section{Background}

\begin{frame}[fragile]{Background}
	\begin{itemize}
		\item<+-> \alert{Satisfiability modulo theories} (SMT) refers to the area
		      of automated reasoning aimed at solving (first-order) satisfiability
		      problems within various mathematical theories.
		      %
		\item<+-> \alert{SMT-LIB} (v2.7) is a formal language
		      used for satisfiability problems and specification
		      of theories.
	\end{itemize}
	%
	\begin{uncoverenv}<+->
		\exxample
		Find $x,y ‚àà ‚Ñ§$ such that $(x + 2y) = 20$ and $(x - y) = 2$.
		\begin{lstlisting}
(set-logic QF_LIA)
(declare-const x Int)
(declare-const y Int)
(assert (= (+ x (* 2 y)) 20))
(assert (= (- x y) 2))
(check-sat)
(exit)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile]
	\begin{uncoverenv}<+->
		For satisfiable specifications,
		\texttt{cvc5} produces an \alert{assignment} for the
		free variables of the input problem.
	\end{uncoverenv}
	\\[3mm]
	\begin{uncoverenv}<+->
		\exxample
		\begin{lstlisting}
(set-logic QF_LIA)
(set-option :produce-models true)
(declare-const x Int)
(declare-const y Int)
(assert (= (+ x (* 2 y)) 20))
(assert (= (- x y) 2))
(check-sat)
(get-model)
(exit)\end{lstlisting}
		\hrule
		\begin{lstlisting}
sat
(
  (define-fun x () Int 8)
  (define-fun y () Int 6)
)\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile]
	\begin{uncoverenv}<+->
		Some SMT solvers produce \alert{proofs} for unsatisfiable problems.
	\end{uncoverenv}
	\\[3mm]
	\begin{uncoverenv}<+->
		\exxample
		\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
(set-logic QF_UF)
(set-option :produce-proofs true)
(declare-const p Bool)
(assert (and p (not p)))
(check-sat)
(get-proof)
(exit)\end{lstlisting}
		\hrule
		\begin{lstlisting}[basicstyle=\ttfamily\footnotesize]
unsat
(declare-fun p () Bool)
(assume @p1 (and p (not p)))
(step @p2 :rule and_elim :premises (@p1) :args (1))
(step @p3 :rule and_elim :premises (@p1) :args (0))
(step @p4 false :rule contra :premises (@p3 @p2))\end{lstlisting}
	\end{uncoverenv}
\end{frame}

\begin{frame}[fragile]{Eunoia and Ethos}
	\begin{itemize}
		\item<+->
		      \alert{Eunoia} is an emerging \emph{logical framework} aimed at
		      formalizing the proof systems used by SMT solvers.
		      \begin{itemize}
			      \item[\emoji{flag-united-states}]<+-> development led by Andrew Reynolds, at University of Iowa.
			      \item[\emoji{ghost}]<+-> the `spiritual successor' of the \alert{Alethe} proof format.
			      \item[\emoji{scroll}]<+-> covers theory signatures \& proof scripts.
			      \item[\emoji{check-mark}]<+-> paired with the \alert{Ethos} checker.
		      \end{itemize}

		\item<+-> Extends SMT-LIB by adding:
		      \begin{itemize}
			      \item<+->(dependent) types, parametric polymorphism
			      \item<+->`programs' (i.e., constants with rewrite rules)
			      \item<+->inference rules, commands for building proofs
		      \end{itemize}

	\end{itemize}
\end{frame}

\begin{frame}[fragile]
	% tikz diagram here for the dir-tree of eo/cpc/...
	% tikz diagram for proof output by cvc5, checked by ethos.
	\begin{itemize}
		\item<+-> The \alert{co-operating proof calculus}
		      (i.e., CPC, the proof system of \texttt{cvc5})
		      is formalized as a Eunoia signature $Œ£_{\cpc}$.

		\item<+-> Proofs produced by \texttt{cvc5} are
		      Eunoia proof scripts that exclusively use
		      the inference rules from $Œ£_{\cpc}$.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{LambdaPi}
	\begin{itemize}
		\item<+-> Logical framework based
		      on the \emph{$ŒªŒ†$-calculus modulo rewriting}.
		      \begin{itemize}
			      \item[\emoji{flag-france}]<+-> development led by Fr√©d√©ric Blanqui, INRIA Paris-Saclay
			      \item[\emoji{locked}]<+-> small and fast, trusted code base
			      \item[\emoji{robot}]<+-> interactive theorem proving via LSP!
		      \end{itemize}

		\item<+-> Primarily focused on proof assistant \alert{interoperability}.

		\item<+-> \emph{\color{oc-green-9}Goal:}
		      Design a translation procedure $T$ such that:
		      \begin{itemize}
			      \item<+-> if $Œ£$ is a Eunoia signature implementing some \alert{logic} $L$,
			      \item<+-> then $T(Œ£)$ is a LambdaPi signature also implementing $L$.
			            \\[2mm]
		      \end{itemize}

		\item<+-> Thus, if $Œ†$ is a valid Eunoia \alert{proof script} depending on $Œ£$,
		      then $T(Œ†)$ should be \alert{well-typed} wrt. $T(Œ£)$.
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Why Eunoia?}
	\begin{itemize}
		\item<+-> What about Alethe?
		      \begin{itemize}
			      \item<+-> inference rules only exist \emph{in papyro}.
			      \item<+-> missing details needed for reconstruction.
			      \item<+->
			            \textbf{Coltellacci and Merz}: extend \alert{Carcara}
			            to allow LambdaPi output.
		      \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{}
	\begin{itemize}
		\item<+-> \emph{\color{oc-green-9}Goal:}
		      Design a translation procedure $T$ such that:
		      \begin{itemize}
			      \item<+-> if $Œ£$ is a Eunoia signature implementing some \alert{logic} $L$,
			      \item<+-> then $T(Œ£)$ is a LambdaPi signature also implementing $L$.
			            \\[2mm]
		      \end{itemize}

		\item<+-> Thus, if $Œ†$ is a valid Eunoia \alert{proof script} depending on $Œ£$,
		      then $T(Œ†)$ should be \alert{well-typed} wrt. $T(Œ£)$.
	\end{itemize}
\end{frame}

\section{Syntax}



\section{Semantics}


\section{Proofs \& Lambdapi}






% TODO.
% smt-lib 3 proposal.
% - dependent types, polymorphism
% - commands
% chad browns notes.
% Eunoia, Ethos.

% SMT-LIB 3 in CC
% proof-irrelevant semantics of CC

% dekuti encoding of CC.
% future proofing:
% translating smt3 concrete syntax into CC does the same for SMT 2.6 and for SMT 2.7.


% some argument about why even though we have a much more expressive logic,
% SMT solvers will only still support a small fragment of it.
% regardless, it is very important for many reasons to

\end{document}



% \begin{frame}[fragile]
% 	\exxample Proof script generated by \textsc{cvc5}.
% 	\begin{lstlisting}
% (declare-const =
%   (-> (! Type :var T :implicit) T T Bool))
% (declare-rule symm ((T Type) (t T) (s T))
%     :premises ((= t s))
%     :conclusion (= s t)
% )
% (declare-type Int ())
% (declare-const a Int)
% (declare-const b Int)
% (assume @p0 (= a b))
% (step @p1 (= b a) :rule symm :premises (@p0))\end{lstlisting}
% 	%
% 	Declaring rules requires adding $\PROP$-level functions, e.g.;
% 	%
% 	$$\msf{symm} :
% 		(\pii {T : \TYPE,\,t : T,\,s : T} {\lift{t = s} ‚Üí \lift{s = t}})$$
% \end{frame}

% \begin{frame}
% 	\begin{itemize}
% 		\item<+-> \emph{\color{oc-green-9}Goal:}
% 		      Implement a translation from SMT-LIB v3 and Eunoia to
% 		      an OCaml representation of CC.
% 		\item<+-> Use axioms of Theory $ùïå$ for encoding CC in Lambdapi.
% 		      %
% 		      $$
% 			      \begin{array}{l@{\quad}l}
% 				      \eval{\TYPE}_{\lp} ‚â° \tt{Set}
% 				       &
% 				      \eval{\lam {x : t_1} {t_2}}_{\lp} ‚â° \lam {x' : \eval{t_1}} {\eval{t_2}}
% 				      \\
% 				      \eval{\PROP}_{\lp} ‚â° \tt{Prop}
% 				       &
% 				      \eval{\pii {x : t_1}{t_2}}_{\lp} ‚â° \eval{t_1}_{\lp} \leadsto^d \eval{t_2}_{\lp}
% 			      \end{array}
% 		      $$
% 	\end{itemize}
% \end{frame}
