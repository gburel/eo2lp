\documentclass[class=llncs, crop=false]{standalone}

\input{preamble.tex}
\input{macros.tex}


\begin{document}
% ---------------------------------------------------------
\begin{boxfigure}[t!]{fig:eo-syntax}
	{Syntax for Eunoia}
	%
	$$ \eoTermSyntax $$
	\hrule
	$$ \eoAttrSyntax $$
	\hrule
	$$ \eoCommandSyntax $$
	% \hrule
	% $$ \eoPrfCommandSyntax $$
\end{boxfigure}
% ---------------------------------------------------------
With respect to a fixed set $ð’®_{\mbf{eo}}$ of \emph{symbols},
the rules in \autoref{fig:eo-syntax} define syntax for a
fragment of Eunoia.
%
In particular, we define sets of expressions
for \emph{terms}, \emph{parameters}, and \emph{attributes}.
%
Each term is either a symbol $s$ or an \emph{application}
$\eoapp{s}{\vec t}$ for some list of terms $\vec t$.
%
% TODO. ref to explanation of variable attributes.
Let $Î½$ and $Î±$ range over \emph{variable attributes}
and \emph{constant attributes} respectively.
%
Then, each \emph{parameter} $Ï$ consists of a symbol $s$,
a term $t$, and possibly a variable attribute $Î½$.
%

Finally, the rules of \autoref{fig:eo-syntax}
define syntax for a subset of Eunoia's top-level commands,
which we will call \emph{standard commands}.
%
Hereinafter, a list $Î”$ of standard commands is a
\emph{signature}, and a list of parameters $Î“$
is a \emph{context}.

\subsubsection{Constant Declaration.}
%
Let $Î´$ be a \emph{(parameterized) constant declaration}
with symbol $s$, parameters $\vec Ï$, and term $t$.
%
If $Î´ âˆˆ Î”$, then $\prn{\vec Ï.\, t}$ is called the
\emph{type} of $s$;
written $\prn{Î” âŠ¢ s : \prn{\vec Ï.\, t}}$.
%
If $Î´$ provides a constant attribute $Î±$,
we write $\prn{Î” âŠ¢ s âˆ· Î±}$.
%

\subsubsection{Macro Definition.}
%
Let $Î´$ be a \emph{macro definition} with
symbol $s$, parameters $\vec Ï$, and term $t$.
%
If $Î´ âˆˆ Î”$, we call $\prn{\vec Ï.\, t}$
the \emph{definiens} of $s$;
written $\prn{Î” âŠ¢ s â‰” \prn{\vec Ï.\, t}}$.
%
If the $\mtt{:type}$ attribute is given with term $t'$,
then $\prn{Î” âŠ¢ s : t'}$ also holds.

\subsubsection{Program Declaration.}
%
Let $Î´$ be a \emph{program declaration} with
symbol $s$, consists of a
variable $x$, a list of parameters $\vec Ï$,
a \emph{signature} $(t_1, \ldots, t_n) â†’ t'$,
and rewrite clauses $r_1,\ldots,r_m$.

\subsubsection{Signature Inclusion.}
%

\subsubsection{Rule Declaration.}
%
A \emph{rule declaration} consists of a variable $x$,
a list of parameters $\vec Ï$,
a list of terms $\plur Ï† n$ called \emph{premises},
a list of terms $t_1, \ldots, t_n$ called \emph{argument patterns},
and a \emph{conclusion} $Ïˆ$.

\subsubsection{Proof Scripts.}
%
A Eunoia \emph{proof script} is a list of
commands of the form $\vec Î´, \vec Ï€$ proof commands.


\subsection{The Co-operating Proof Calculus}
\label{sec:eo-proof}

\end{document}


% \subsection{Terms, Types and Attributes}
% %
% The \emph{built-in constants} of Eunoia are given by a fixed
% subset of symbols and denoted by the following expressions:
% $\mtt{Type}$ (the kind of all types),
% $\mtt{->}$ (arrow-type constructor),
% $\mtt{\_}$ (binary function application),
% $\mtt{Bool}$ (the type of Boolean values),
% $\mtt{true}$ and $\mtt{false}$ (terms of type \mtt{Bool}).
