\documentclass[class=llncs, crop=false]{standalone}

\input{preamble.tex}
\input{macros.tex}


\begin{document}
% ---------------------------------------------------------
\begin{boxfigure}[t!]{fig:term-syntax}
	{Syntax for Eunoia}
	%
	$$ \eoTermSyntax $$
	\hrule
	$$ \eoAttrSyntax $$
	\hrule
	$$ \eoCommandSyntax $$
	\hrule
	$$ \eoPrfCommandSyntax $$
\end{boxfigure}
% ---------------------------------------------------------
Syntax for a fragment of Eunoia is given by
\autoref{fig:term-syntax} and \autoref{fig:command-syntax}.
%
With respect to a fixed set $ùíÆ_{\mbf{eo}}$ of \emph{symbols},
the rules in \autoref{fig:term-syntax} define sets of
expressions for \emph{terms}, \emph{attributes}, and
\emph{parameters}.
%
Each term is either a symbol $s$ or an \emph{application}
$\eoapp {s} {\vec e}$ for some list of terms $\vec e$.
%
Let $ŒΩ$ and $Œ±$ range over \emph{variable attributes}
and \emph{constant attributes} respectively.
Then, each \emph{parameter} $œÅ$ is an expression
consisting of a symbol $s$, a term $t$, and an (optional)
variable attribute $ŒΩ$.
%

\begin{boxfigure}[t!]{fig:command-syntax}
	{Syntax for top-level Eunoia commands.}
	%
	$$ \eoCommandSyntax $$

\end{boxfigure}
%
\Autoref{fig:command-syntax} defines the syntax for Eunoia's
top-level \emph{commands}. The expressions generated by $Œ¥$
are called \emph{standard} commands, and those generated
by $œÄ$ are called \emph{proof commands}.
%
Hereinafter, a Eunoia \emph{signature} is a list $\vec Œ¥$
of standard commands, and a Eunoia \emph{proof script} is a
list $\vec œÄ$ of proof commands.
%
The operational meaning of each standard command is discussed
directly below, and the meaning of proof commands is discussed
in \autoref{sec:eo-proof}.
%


\subsection{Terms, Types and Attributes}
%
The \emph{built-in constants} of Eunoia are given by a fixed
subset of symbols and denoted by the following expressions:
$\mtt{Type}$ (the kind of all types),
$\mtt{->}$ (arrow-type constructor),
$\mtt{\_}$ (binary function application),
$\mtt{Bool}$ (the type of Boolean values),
$\mtt{true}$ and $\mtt{false}$ (terms of type \mtt{Bool}).


\subsection{Commands and Signatures}



\subsubsection{Constant Declarations}
%
A \emph{(constant) declaration} consists of a
variable $x$, a list of parameters $\vec œÅ$,
a term $t$, and a constant attribute $Œ±$.
%
A \emph{(constant) definition} consists of a
variable $x$ and terms $t$, $t'$.

\subsubsection{Type Declarations and Definitions}


\subsubsection{Macros and Programs}
%
A \emph{program} consists of a
variable $x$, a list of parameters $\vec œÅ$,
a \emph{signature} $(t_1, \ldots, t_n) ‚Üí t'$,
and rewrite clauses $r_1,\ldots,r_m$.

\subsubsection{Signature Inclusions}
%

\subsection{Rule Declarations and Proof Scripts}
%
A \emph{rule declaration} consists of a variable $x$,
a list of parameters $\vec œÅ$,
a list of terms $\plur œÜ n$ called \emph{premises},
a list of terms $t_1, \ldots, t_n$ called \emph{argument patterns},
and a \emph{conclusion} $œà$.

% The overall architecture of our method is as follows:
% \begin{itemize}
% 	\item We parse Eunoia files using an \texttt{ocamllex} lexer and a parser
% 	      generated by \texttt{menhir}. The grammar used for generating the
% 	      parser is largely based off the grammar in the Eunoia user manual.

% 	\item We translate Eunoia specifications to an abstract syntax given by an
% 	      OCaml datatype. During this phase, we eliminate applications of
% 	      operators declared to be $n$-ary (e.g., \texttt{and}, \texttt{or}).
% \end{itemize}

\label{sec:eo-proof}

\end{document}
