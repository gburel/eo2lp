\documentclass[class=llncs, crop=false]{standalone}

\input{preamble.tex}
\input{macros.tex}


\begin{document}
% ---------------------------------------------------------
\begin{boxfigure}[t!]{fig:eo-syntax}
	{Syntax for Eunoia}
	%
	$$ \eoTermSyntax $$
	\hrule
	$$ \eoAttrSyntax $$
	\hrule
	$$ \eoCommandSyntax $$
	% \hrule
	% $$ \eoPrfCommandSyntax $$
\end{boxfigure}
% ---------------------------------------------------------
With respect to a fixed set $ð’®_{\mbf{eo}}$ of \emph{symbols},
the rules in \autoref{fig:eo-syntax} define syntax for a
fragment of Eunoia.
%
In particular, we define sets of expressions
for \emph{terms}, \emph{parameters}, and \emph{attributes}.
%
Each term is either a symbol $s$ or an \emph{application}
$\eapp{s}{\vec t}$ for some list of terms $\vec t$.
%
% TODO. ref to explanation of variable attributes.
Let $Î½$ and $Î±$ range over \emph{variable attributes}
and \emph{constant attributes} respectively.
%
Then, each \emph{parameter} $Ï$ consists of a symbol $s$,
a term $t$, and possibly a variable attribute $Î½$.
%

Finally, the rules of \autoref{fig:eo-syntax}
define syntax for a subset of Eunoia's top-level commands,
which we will call \emph{standard commands}.
%
Hereinafter, a Eunoia \emph{signature} is a list $Î”$
of standard commands. We define some
`abstract syntax' for working with signatures below.

\subsubsection{Constant Declaration.}
%
Let $Î´$ be a \emph{(parameterized) constant declaration}
with symbol $s$, parameters $\vec Ï$, and term $t$.
%
If $Î´ âˆˆ Î”$, then $\prn{\vec Ï.\, t}$ is called the
\emph{type} of $s$;
written $\prn{Î” âŠ¢ s : \prn{\vec Ï.\, t}}$.
%
If $Î´$ provides a constant attribute $Î±$,
we write $\prn{Î” âŠ¢ s âˆ· Î±}$.
%

\subsubsection{Macro Definition.}
%
Let $Î´$ be a \emph{macro definition} with
symbol $s$, parameters $\vec Ï$, and term $t$.
%
If $Î´ âˆˆ Î”$, we call $\prn{\vec Ï.\, t}$
the \emph{definiens} of $s$;
written $\prn{Î” âŠ¢ s â‰” \prn{\vec Ï.\, t}}$.
%
If the attribute $\mtt{:type}\ t'$ is given by $Î´$,
then $\prn{Î” âŠ¢ s : \prn{\vec Ï.\, t'}}$ also holds.

\subsubsection{Program Declaration.}
%
Let $Î´$ be a \emph{program declaration} with
symbol $s$, parameters $\vec Ï$,
attribute $\mtt{:signature}\,\prn{\vec t}\,t'$,
and term-pairs $\vec r$.
%
If $Î´ âˆˆ Î”$ and $\vec t = \plur t n$,
we say that $s$ has \emph{domain} $(\plurcomma t n)$,
\emph{range} $t'$ and \emph{cases} $\vec r$
with respect to the parameters $\vec Ï$.
%
More formally, we write
  $\prn{Î” âŠ¢ s : \prn{\vec Ï.\,\earr{\plur t n\, t'}}}$
for the type of $s$,
and
  $\prn{Î” âŠ¢ s â‰” \mbf{cases}(\vec Ï.\ r_1, \ldots, r_n)}$
for the cases.
%
\subsubsection{Rule Declaration.}
%
Let $Î´$ be a \emph{rule declaration} with symbol $s$,
parameters $\vec Ï$, and \emph{conclusion} $Ïˆ$.
%
Suppose also that $Î´$ provides attributes
$\mtt{:premises}\ \epar{\vec Ï†}$,
$\mtt{:args}\ \epar{\vec t}$,
and $\mtt{:requires}\ \epar{\vec r}$.
%
If $Î´ âˆˆ Î”$, then we may write:
  $$Î” âŠ¢ s : \prn{\vec Ï.\ \mbf{infer}(Ïˆ âˆ£ \vec Ï†, \vec t, \vec r)}$$


\subsubsection{Signature Inclusion.}
%
We assume a \emph{(global) environment}
$Î˜$ which maps filepaths to Eunoia signatures.
%
Thus, whenever $\epar{\mtt{include}\ Î¼} âˆˆ Î”$
for some path $Î¼$, the signature $Î”$ inherits
all of the declarations made by $Î˜(Î¼)$.

% ----------------------------------------------------------
\subsection{Elaboration of Terms}
%
The meaning of an application $\eapp{s}{\vec t}$
depends on the constant attribute of $s$.
%
For example, consider a signature $Î”$ containing
the following constant declaration:
$$\dca{\eor}{\earr{\bool\ \bool\ \bool}}{\rcn \false}$$
%
The type of $\eor$ is declared to be
${\earr{\bool\ \bool\ \bool}}$,
and so we may expect that its only valid
uses are of the form $\eapp{\eor}{t_1\ t_2}$
for some terms $t_1$, $t_2$.
%
However, the assignment of the constant attribute means
that the $\mtt{or}$ symbol is treated as
\emph{right-associative} with \emph{nil-terminator} $\false$.
%
Thus, $n$-ary applications of $\eor$ will
be \emph{elaborated} to a normal form, e.g.;
%
$$\eapp{\eor}{\ev x\ \ev y\ \ev z}\ â‡¢\
  \eapp{\eor}{\ev x\ \eapp{\eor}{\ev y\ \eapp{\eor}{\ev z\ \false}}}$$
%
Moreover, the normal form of an $n$-ary applications may
depend upon the attributes of `locally bound' symbols.
For example, consider $\vec Ï$ containing
$\epar{\ev x\ \bool}$,
$\epar{\ev y\ \bool\ \mtt{:list}}$,
and $\epar{\ev z\ \bool}$.
%
Then, $\eapp{\eor}{\ev x\ \ev y\ \ev z}$ will be
elaborated as follows:
$$
\eapp{\eor}{\ev x\ \ev y\ \ev z}
\ {â‡¢}
\ \econs\eor{\ev x}{
\econcat{\eor}{\ev y}{\eapp{\eor}{\ev z\ \false}}
}
$$
%
The $\mtt{:list}$ attribute alters the elaboration strategy
under the assumption that $\ev y$ will (eventually) be
substituted for some $\eor$-list.
%
For example, consider the result of substituting
$\ev y â†¦ \econs\eor{\ev w}{\false}$
thus:
$$
\begin{array}[t]{c}
\econs\eor{\ev x}{
\econcat{\eor}{\econs\eor{\ev w}{\false}}
  {\eapp{\eor}{\ev z\ \false}}}
\\[1mm] {â‡£} \\[1mm]
  \econs\eor{\ev x}{
  \econs\eor{\ev w}{
    \econs\eor{\ev z}{\false}}
  }
\end{array}
$$
%
To support the variety of elaboration strategies
corresponding to the different constant attributes,
we define an \emph{elaboration} operator below.
%
\begin{definition}
For any symbol $f$ and list of parameters $\vec Ï$,
let $\glue{\vec Ï,f}$ be the binary operator
such that for any terms $t_1$, $t_2$, the following holds:
%
$$
\glue{\vec Ï,f}[t_1,t_2] =
\begin{cases}
  \econcat{f}{t_1}{t_2} & \text{if $Î“ âŠ¢ t_1 âˆ· \mtt{:list}$,}
  \\
  \econs{f}{t_1}{t_2} & \text{otherwise.}
\end{cases}
$$
%
Then for any signature $Î”$, let $\elab{Î”,\vec Ï}$
be the least (unary) operator such that for any
symbol $f$ and terms $\vec t = \plur t n$,
the following holds:
$$
\begin{array}[t]{r@{\ =\ }l}
  \elab{Î”,\vec Ï}[f] & f
  \\
  \elab{Î”,\vec Ï}[\eapp{f}{\vec t}]
  &
  \begin{cases}
    \foldr(G, t_\nil, \vec t)
    & \text{if $Î” âŠ¢ f âˆ· \rcn{t_\nil}$, }
    \\
    \foldl(G', t_\nil, \vec t)
    & \text{if $Î” âŠ¢ f âˆ· \lcn{t_\nil}$,}
    \\
    \foldr(G, t_n, \plur t {n-1})
    &
    \text{if $Î” âŠ¢ f âˆ· \rc$,}
    \\
    \foldl(G', t_n, \plur t {n-1})
    &
    \text{if $Î” âŠ¢ f âˆ· \lc$,}
    \\
    \eapp{f}{{t_1'}\ldots{t_n'}}
    &
    \text{otherwise.}
    % \econs{f}{t_1}{t_2} & \text{otherwise.}
  \end{cases}
\end{array}
$$
where $G â‰” \glue{\vec Ï, f}[x,y]$,
and $G'(x,y) â‰” G(y,x)$,
and $t_i' â‰” \elab{Î”, \vec Ï}[t_i]$.
% for $1 â‰¤ i â‰¤ n$.

\end{definition}
%













% ----------------------------------------------------------
\subsection{Proof Scripts}
%
\begin{boxfigure}[t!]{fig:eo-prf-commands}
 {Syntax for Eunoia proof commands.}
 $$ \eoPrfCommandSyntax $$
\end{boxfigure}
%
\Autoref{fig:eo-prf-commands} provides syntax for two
basic forms of Eunoia \emph{proof commands}, which are
called  \emph{assumption} and \emph{step}.
%
Each \emph{proof script} $Î $ is a list
$\prn{\vec Î´; \vec Ï€}$ where
$\vec Î´$ is a list of standard commands called
the \emph{preamble} and $\vec Ï€$ are proof commands.
%

Given $\epar{\mtt{assume}\ s\ t} âˆˆ Î $,
we write $\prn{Î  âŠ¢ s â‰” \hyp(t)}$.
%
Furthermore, let $Ï€$ be a proof step with symbol $s$,
\emph{conclusion} $Ïˆ$, and attributes $\mtt{:premises}\ \vec{Ï†}$
and $\mtt{:args}\ \vec{t}$.
%
Then we may write $\prn{Î  âŠ¢ s â‰” \step(s', Ï†, \vec Ïˆ, \vec t)}$
iff $Ï€ âˆˆ Î $.
% In practice, an Eunoia-friendly SMT solver will give
% its proofs with respect to some fixed signature $Î”$.
%
% We define We say that a proof scripts is \emph{valid} with respect
% to $Î”$ iff a list of
% commands of the form $\vec Î´, \vec Ï€$ proof commands.



\end{document}


% \subsection{Terms, Types and Attributes}
% %
% The \emph{built-in constants} of Eunoia are given by a fixed
% subset of symbols and denoted by the following expressions:
% $\mtt{Type}$ (the kind of all types),
% $\mtt{->}$ (arrow-type constructor),
% $\mtt{\_}$ (binary function application),
% $\mtt{Bool}$ (the type of Boolean values),
% $\mtt{true}$ and $\mtt{false}$ (terms of type \mtt{Bool}).
