\documentclass[class=llncs, crop=false]{standalone}

\input{preamble.tex}
\input{macros.tex}


\begin{document}
% ---------------------------------------------------------
\begin{boxfigure}[t!]{fig:term-syntax}
	{Syntax for Eunoia symbols, terms, and parameters, and attributes.}
	%
	$$ \eoTermSyntax $$
\end{boxfigure}
% ---------------------------------------------------------

% ---------------------------------------------------------
Abstract syntax for Eunoia is given by
\autoref{fig:term-syntax} and \autoref{fig:command-syntax}.
%
The rules in \autoref{fig:term-syntax} define sets of
expressions for the \emph{symbols}, \emph{terms}, \emph{attributes},
and \emph{parameters} of Eunoia.
%
Each symbol $s$ belongs to the countably infinite set
of tokens $\{\sym 0, \sym 1, \ldots \}$, and
each term $e$ is either a symbol, or an \emph{application}
$\eoapp {s} {\vec e}$ for some list of terms $\vec e$.
%
The non-terminals $ν$ and $α$ range over
\emph{variable attributes} and \emph{constant attributes}
respectively.
%
Each \emph{parameter} $ρ$ is an expression
consisting of a symbol, a term, and an optional variable attribute.
%

\subsection{Terms, Types and Attributes}
%
The \emph{built-in constants} of Eunoia are given by a fixed
subset of symbols and denoted by the following expressions:
$\mtt{Type}$ (the kind of all types),
$\mtt{->}$ (arrow-type constructor),
$\mtt{\_}$ (binary function application),
$\mtt{Bool}$ (the type of Boolean values),
$\mtt{true}$ and $\mtt{false}$ (terms of type \mtt{Bool}).

%
\begin{boxfigure}[t]{fig:command-syntax}
	{Syntax for top-level Eunoia commands.}
	%
	$$ \eoCommandSyntax $$
	$$ \eoPrfCommandSyntax $$
\end{boxfigure}
%
\subsection{Commands and Signatures}

\Autoref{fig:command-syntax} defines the syntax for Eunoia's
top-level \emph{commands}. The expressions generated by $δ$
are called \emph{standard} commands, and those generated
by $π$ are called \emph{proof commands}.
%
Hereinafter, a Eunoia \emph{signature} is a list $\vec δ$
of standard commands, and a Eunoia \emph{proof script} is a
list $\vec π$ of proof commands.
%
The operational meaning of each standard command is discussed
directly below, and the meaning of proof commands is discussed
in \autoref{sec:eo-proof}.
%


\subsubsection{Constant Declarations}
%
A \emph{(constant) declaration} consists of a
variable $x$, a list of parameters $\vec ρ$,
a term $t$, and a constant attribute $α$.
%
A \emph{(constant) definition} consists of a
variable $x$ and terms $t$, $t'$.

\subsubsection{Type Declarations and Definitions}


\subsubsection{Macros and Programs}
%
A \emph{program} consists of a
variable $x$, a list of parameters $\vec ρ$,
a \emph{signature} $(t_1, \ldots, t_n) → t'$,
and rewrite clauses $r_1,\ldots,r_m$.

\subsubsection{Signature Inclusions}
%

\subsection{Rule Declarations and Proof Scripts}
%
A \emph{rule declaration} consists of a variable $x$,
a list of parameters $\vec ρ$,
a list of terms $\plur φ n$ called \emph{premises},
a list of terms $t_1, \ldots, t_n$ called \emph{argument patterns},
and a \emph{conclusion} $ψ$.

% The overall architecture of our method is as follows:
% \begin{itemize}
% 	\item We parse Eunoia files using an \texttt{ocamllex} lexer and a parser
% 	      generated by \texttt{menhir}. The grammar used for generating the
% 	      parser is largely based off the grammar in the Eunoia user manual.

% 	\item We translate Eunoia specifications to an abstract syntax given by an
% 	      OCaml datatype. During this phase, we eliminate applications of
% 	      operators declared to be $n$-ary (e.g., \texttt{and}, \texttt{or}).
% \end{itemize}

\label{sec:eo-proof}

\end{document}
