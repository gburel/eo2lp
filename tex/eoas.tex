\documentclass[class=llncs, crop=false]{standalone}

\input{preamble.tex}
\input{macros.tex}

\begin{document}
% ---------------------------------------------------------
\begin{boxfigure}[t!]{fig:eo-syntax}
	{Syntax for Eunoia: terms, attributes, and commands.}
	%
	$$ \eoTermSyntax $$
	\hrule
	$$ \eoAttrSyntax $$
	\hrule
	$$ \eoCommandSyntax $$
	\hrule
	$$ \eoPrfCommandSyntax $$
\end{boxfigure}
% ---------------------------------------------------------
With respect to a fixed set $ð’®_{\mbf{eo}}$ of \emph{symbols},
the rules in \autoref{fig:eo-syntax} define syntax for a
fragment of Eunoia.
%
In particular, we define sets of expressions
for \emph{terms}, \emph{parameters}, and \emph{attributes}.
%
Each term is either a symbol $s$ or an \emph{application}
$\eapp{s}{\vec t}$ for some list of terms $\vec t$.
%
% TODO. ref to explanation of variable attributes.
Let $Î½$ and $Î±$ range over \emph{variable attributes}
and \emph{constant attributes} respectively.
%
Then, each \emph{parameter} $Ï$ consists of a symbol $s$,
a term $t$ (the type of the paramater), and possibly a variable attribute $Î½$.
%

The rules of \autoref{fig:eo-syntax} define a subset
of Eunoia \emph{commands},
which are divided into \emph{standard commands}
and \emph{proof commands}.
%
Hereinafter, a Eunoia \emph{signature} is a list $Î”$
of standard commands, and a \emph{proof script} is a
list $Î¥ = \prn{\vec Î´ â¨¾ \vec Ï€}$
where $\vec Î´$ is a list of standard commands called
the \emph{preamble} and $\vec Ï€$ is a list of
proof commands called the \emph{body} of the script.
%
The preamble of $Î¥$ should be understood as the encoding
of an `input problem', and the body understood as a
proof of the unsatisfiability of the problem.

In practice, a Eunoia-friendly solver should have
a trusted signature $Î”$ declaring a bespoke set of
constants and inference rules.
%
The correctness of a generated proof script $Î¥$ may then
be checked with respect to $Î”$ using the Ethos tool.
%

\subsection{Commands and their Declarations}
%
We proceed to define an abstract interface for `reading'
information from signatures and proof scripts.
%
This interface is useful for
characterizing the \emph{elaboration}
and \emph{translation} operators
found in \autoref{sec:eo-elab} and
\autoref{sec:results} respectively.

\subsubsection{Constant Declaration.}
%
Let $Î´$ be a \emph{(parameterized) constant declaration}
with symbol $s$, parameters $\vec Ï$, and term $t$.
%
We may write $\prn{Î´ âŠ¢ s(\vec Ï) : t}$ to express
that the command $Î´$ declares $t$ as the \emph{type} of $s$
with respect to a parameters $\vec Ï$.
%
Furthermore, if a constant attribute $Î±$ is given by $Î´$,
we may write $\prn{Î´ âŠ¢ s(\vec Ï) âˆ· Î±}$.
%

\subsubsection{Macro Definition.}
%
Let $Î´$ be a \emph{macro definition} with
symbol $s$, parameters $\vec Ï$, and term $t$.
%
Then $Î´$ declares $t$ as the \emph{definiens} of $s$
wrt. $\vec Ï$; written $\prn{Î´ âŠ¢ s(\vec Ï) â‰” t}$.
%
If the attribute $\mtt{:type}\ t'$ is given by $Î´$,
then $\prn{Î´ âŠ¢ s(\vec Ï) : t'}$ also holds.

\subsubsection{Program Declaration.}
%
Let $Î´$ be a \emph{program declaration} with
symbol $s$, parameters $\vec Ï$,
$\mtt{:signature}\,\prn{\plur t n}\,t'$,
and cases $\plur c m$.
%
Then, $Î´$ declares the type and definiens of $s$
as follows,
where $\plur t n$ are the \emph{domain} types of $s$
and $t'$
is \emph{range}:
% Let $\vec t = \plur t n$ and $\vec r = \plur r m$,
% and $Î´ âˆˆ Î”$.
% $(\plurcomma t n)$, \emph{range} $t'$ and
% \emph{cases} $\vec r$ with respect to $\vec Ï$.
%
% More formally, we may write:
  $$
  Î´ âŠ¢ s(\vec Ï) : \earr{\plur t n\, t'}
\quad\text{and}\quad
  Î´ âŠ¢ s(\vec Ï) â‰” \mbf{cases}[c_1, \ldots, c_m]
$$
% for the type of $s$,
% and
%   $$
% for the cases.
%
\subsubsection{Inference Rule Declaration.}
%
Let $Î´$ be a \emph{rule declaration} with symbol $s$,
parameters $\vec Ï$, and \emph{conclusion} $Ï†$.
%
Also, suppose $Î´$ provides
$\mtt{:premises}\ \epar{\plur Ïˆ n}$,
$\mtt{:args}\ \epar{\plur t m}$ with types $\plur Ï„ m$,
and $\mtt{:requires}\
  \epar{\epar{x_1\ y_1}\ldots\epar{x_o\ y_o}}$.
%
First, let $Î´$ declare the type and definiens
of an \emph{auxiliary symbol} for $s$ thus:
$$
\begin{array}[t]{l@{\ âŠ¢\ }l}
Î´ & s^â­‘(\vec Ï) : \earr{\plur Ï„ m\ \bool}
\\[1mm]
Î´ & s^â­‘(\vec Ï) â‰” \mbf{cases}
  [\;
    \epar{{\eapp{s^â­‘}{\plur t m}}\ Ï†}
    âˆ£
\epar{x_1\ y_1}\ldots\epar{x_k\ y_k}%%Guillaume: should be o ?
  \;]
\end{array}
$$
%
Then, the type of $s$ is given by $Î´$ with an extended list of parameters%
\footnote{The symbols chosen for $\plur Î± m$ must be \emph{fresh} with respect to $Î´$.
  That is, each $Î±_i$ is distinct from any symbol occurring in any of the
  terms or parameters supplied by $Î´$.}
thus:
  $$Î´ âŠ¢ s(\vec Ï, \epar{Î±_1\ Ï„_1} \ldots \epar{Î±_n\ Ï„_m}) :
  \earr{
    \epar{\mtt{Proof}\ Ïˆ_1} \ldots
    \epar{\mtt{Proof}\ Ïˆ_n}\
    \epar{\mtt{Proof}\ Ï†^â­‘}
  }$$
where $Ï†^â­‘ â‰” \eapp{s^â­‘}{\plur Î± n}$
ensures that a term of type $\eapp{\mtt{Proof}}{Ï†}$
may only be obtained iff $\prn{Î±_i = t_i}$
for $1 â‰¤ i â‰¤ m$ and $\prn{x_j = y_j}$ for $1 â‰¤ j â‰¤ o$.
% and $$.

\subsubsection{Signature Inclusion.}
%
Hereinafter, let $Î˜$ be a \emph{(global) environment}
mapping from filepaths to Eunoia signatures.
%
Let $Î´$ be an inclusion with valid filepath $Î¼$.
Then, any judgement $J$ made by a command $Î´'$ in $Î˜_Î¼$
is also made by $Î´$.
That is:
$$
\text{$âˆ€\,Î´' âˆˆ Î˜_Î¼$,}\quadÎ´' âŠ¢ J \quadâŸ¹\quad \epar{\mtt{include}\ Î¼} âŠ¢ J
$$

\subsubsection{Proof Scripts.}

Two basic forms of \emph{proof commands} are given,
which are called \emph{assumption} and \emph{step}
respectively.
%
Given $Ï€ = \epar{\mtt{assume}\ s\ Ï†}$ or
$Ï€ = \epar{\mtt{step}\ s\ Ï†\ \ldots}$, we call
$s$ the \emph{name} of $Ï€$ and $Ï†$ the \emph{conclusion}.
%
In either case, we may write:
$$Ï€ âŠ¢ s : \eapp{\mtt{Proof}}{Ï†}$$
%
Furthermore, let $Ï€$ be a step with
$\mtt{:rule}\ s'$,
$\mtt{:premises}\ \epar{\vec p}$, and
$\mtt{:args}\ \epar{\vec t}$.
%
Then, $Ï€$ judges the definiens of $s$
as the application of $s'$ to the premises
$\plur p n$ and arguments $\plur t m$, i.e.;
$$Ï€ âŠ¢ s â‰” \eapp{s'}{\plur t m\ \plur p n}$$
%



% iff $Ï€ âˆˆ Î $.

%
% We define We say that a proof scripts is \emph{valid} with respect
% to $Î”$ iff a list of
% commands of the form $\vec Î´, \vec Ï€$ proof commands.



% ----------------------------------------------------------
\subsection{Elaboration of Terms}\label{sec:eo-elab}
%
In Eunoia, the `de-sugared' meaning of an application
$\eapp{s}{\vec t}$ depends on the constant attribute
assigned to $s$ within some signature $Î”$.
%
For example, consider a constant declaration $Î´$ with:
$$
Î´ âŠ¢ \eor : \earr{\bool\ \bool\ \bool}
\quad\text{and}\quad
Î´ âŠ¢ \eor âˆ· {\rcn \false}
$$
% and $Î´ âŠ¢ $.
% $$\dca{\eor}{\earr{\bool\ \bool\ \bool}}$$
%
From the type of $\eor$, we may expect its only valid
uses to be of the form $\eapp{\eor}{t_1\ t_2}$.
%
However, the assignment of the constant attribute means
that the $\mtt{or}$ symbol is treated as
\emph{right-associative} with \emph{nil-terminator} $\false$.
%
Thus, $n$-ary applications of $\eor$ are
\emph{elaborated} to a normal form, e.g.;
%
$$\eapp{\eor}{\ev x\ \ev y\ \ev z}\ â‡¢\
  \eapp{\eor}{\ev x\ \eapp{\eor}{\ev y\ \eapp{\eor}{\ev z\ \false}}}$$
%
Furthermore, the elaboration of such applications may
also depend on the attributes of `locally bound' symbols.
For example, consider $\vec Ï$ containing
parameters $\epar{\ev x\ \bool}$,
$\epar{\ev y\ \bool\ \mtt{:list}}$,
and $\epar{\ev z\ \bool}$.
%
Then, observe:
$$
\eapp{\eor}{\ev x\ \ev y\ \ev z}
\ {â‡¢}
\ \econs\eor{\ev x}{
\econcat{\eor}{\ev y}{\eapp{\eor}{\ev z\ \false}}
}
$$
%%Guillaume: explain the eo::concat function
%
The $\mtt{:list}$ attribute alters the elaboration strategy
under the assumption that $\ev y$ will (eventually) be
substituted for some $\eor$-list.
%
It may be helpful for the reader
to consider the result of substituting
$\ev y â†¦ \econs\eor{\ev w}{\false}$
thus:
$$
\begin{array}[t]{c}
\econs\eor{\ev x}{
\econcat{\eor}{\econs\eor{\ev w}{\false}}
  {\eapp{\eor}{\ev z\ \false}}}
\\[1mm] {â‡£} \\[1mm]
  \econs\eor{\ev x}{
  \econs\eor{\ev w}{
    \econs\eor{\ev z}{\false}}
  }
\end{array}
$$
%
With the aim of supporting the elaboration strategies
corresponding to the constant attributes given in
\autoref{fig:eo-syntax},
we define an \emph{elaboration} operator below.
%
\begin{definition}
For any symbol $f$ and list of parameters $\vec Ï$,
let $\glue{\vec Ï,f}$ be the binary operator
such that for any terms $t_1$, $t_2$, the following holds:
%
$$
\glue{\vec Ï,f}[t_1,t_2] =
\begin{cases}
  \econcat{f}{t_1}{t_2} & \text{if $\vec Ï âŠ¢ t_1 âˆ· \mtt{:list}$,}
  \\
  \econs{f}{t_1}{t_2} & \text{otherwise.}
\end{cases}
$$
%
Then for any signature $Î”$, let $\elab{Î”,\vec Ï}$
be the least (unary) operator such that for any
symbol $f$ and terms $\vec t = \plur t n$,
the following holds:
$$
\begin{array}[t]{r@{\ =\ }l}
  \elab{Î”,\vec Ï}[f] & f
  \\[1mm]
  \elab{Î”,\vec Ï}[\eapp{f}{\vec t}]
  &
  \begin{cases}
    \foldr(G, t_\nil, \vec t')
    & \tsm{if $Î” âŠ¢ f âˆ· \rcn{t_\nil}$, }
    \\
    \foldl(G', t_\nil, \vec t')
    & \tsm{if $Î” âŠ¢ f âˆ· \lcn{t_\nil}$,}
    \\
    \foldr(G, t'_n, t'_1\ldots t'_{n-1})
    &
    \tsm{if $Î” âŠ¢ f âˆ· \rc$,}
    \\
    \foldl(G', t'_1, t'_2\ldots t'_{n})
    &
    \tsm{if $Î” âŠ¢ f âˆ· \lc$,}
    \\
    \eapp{f}{{t_1'}\ldots{t_n'}}
    &
    \tsm{otherwise.}
    % \econs{f}{t_1}{t_2} & \text{otherwise.}
  \end{cases}
\end{array}
$$
where $G â‰” \glue{\vec Ï, f}[x,y]$,
and $G'(x,y) â‰” G(y,x)$,
and $t_i' â‰” \elab{Î”, \vec Ï}[t_i]$.
% for $1 â‰¤ i â‰¤ n$.

\end{definition}
$\foldl(G, a, l)$ (resp.\ $\foldr(G, a, l)$) is the standard
left fold (resp.\ right fold) using combining function $G$ and accumulator $a$ on list $l$.
%













% ----------------------------------------------------------


\end{document}


% \subsection{Terms, Types and Attributes}
% %
% The \emph{built-in constants} of Eunoia are given by a fixed
% subset of symbols and denoted by the following expressions:
% $\mtt{Type}$ (the kind of all types),
% $\mtt{->}$ (arrow-type constructor),
% $\mtt{\_}$ (binary function application),
% $\mtt{Bool}$ (the type of Boolean values),
% $\mtt{true}$ and $\mtt{false}$ (terms of type \mtt{Bool}).
