\documentclass[class=llncs, crop=false]{standalone}
\input{preamble.tex}
\input{macros.tex}

\begin{document}

\begin{boxfigure}[t!]{fig:lpTermSyntax}
	{Syntax and typing rules for the $\lp$-calculus.}
	%
	$$\lpTermSyntax$$
	\hrule
	$$\lpTypingRules$$
	\hrule
	$$ \lpWfRules $$
	%
\end{boxfigure}
%
\Autoref{fig:lpTermSyntax} provides abstract syntax
for the \emph{$\lp$-calculus modulo rewriting}.
%
In particular, the rules in \autoref{fig:lpTermSyntax}
define the \emph{terms} of the $\lp$-calculus.
%
Each term is either a \emph{variable} $x$,
a \emph{constant} $κ$,
a \emph{universe} from $\{ \TYPE, \KIND \}$,
an \emph{application} of two terms $\prn{\app{t}{t'}}$,
or an \emph{abstraction}
$\prn{\binddot{\mscr{B}}{x : t}{t'}}$
where $\mscr{B}$ is a \emph{binder} from $\{ λ, Π \}$.
% TODO. define/declare α-conversion and β-reduction.
Terms are identified up to $α$-conversion
(i.e., renaming of bound variables), and we assume
the usual definitions for \emph{substitution} $\prn{t[x ↦ t']}$
and \emph{$β$-reduction} $\prn{t ⇝_{β} t'}$.

% --------------------------------------------------------%
% \begin{boxfigure}[t!]{fig:lpCtxSyntax}
% 	{Abstract syntax for $\lp$-contexts.}
% 	%
% 	$$\lpCtxSyntax$$
% 	%
% \end{boxfigure}
A \emph{typing} is an expression of the form $\prn{t : t'}$
for some terms $t$, $t'$, and a \emph{context} is a set of
typings of the form $\prn{x : t}$ for some variable $x$ and
term $t$.
%
Hereinafter, given a context $Γ$ and a typing $\prn{x : t}$,
let $\prn{Γ, \prn{x : t}}$ denote the extension $Γ ∪ \{x : t\}$.
%
A \emph{rewrite rule} is an expression of the form
$\prn{ℓ ↪ r}$, where $ℓ$ and $r$ are terms such that
$ℓ$ has the form
$\prn{\app{\prn{\app{κ}{t_1}} ⋅ \ldots}{t_n}}$
for some terms $\plur t n$.
% -------------------------------------------------------- %
% \begin{boxfigure}[t!]{fig:lpTypingRules}
% 	{Typing rules for the $\lp$-calculus.}
% 	%
% 	$$ \lpTypingRules $$
% 	\hrule
% 	$$ \lpWfRules $$
% \end{boxfigure}
% ----
A \emph{signature} is a set whose elements are either
typings or rewrite rules, where each typing
is of the form $\prn{κ : t}$ for some constant $κ$ and
term $t$.
%
Given some signature $Σ$, let $R_{Σ}$ be the smallest
binary relation such that:
%
\begin{enumerate}
	\item $\prn{ℓ ↪ r} ∈ Σ$ implies $(ℓ, r) ∈ R_{Σ}$, and
	\item $R_{Σ}$ is closed under application, abstraction,
	      and substitution.
\end{enumerate}
%
%, abstraction and substitution.  $R$
Then, \emph{equality modulo rewriting} $\prn{{≡_{Σ}}}$ is
defined as the least equivalence relation containing
$R_Σ$ and the $β$-reduction relation.
Furthermore, the rules in \autoref{fig:lpTermSyntax}
provide a (mutually inductive) definition of a
\emph{well-formedness} relation $\prn{\msf{wf}}$ on
contexts and a \emph{typing relation}
$\prn{⊢_{Σ}}$ between contexts and typings,
where $\prn{Γ ⊢_{Σ} e : t}$ may be read as
``$Γ$ proves $e$ has type $t$ with respect to $Σ$''.

% The rules in \autoref{fig:lpCtxSyntax} define
% a \emph{context element} $γ$ as either a \emph{typing}
% $\prn{x : t}$, or a \emph{rewrite rule} .
% %
% Furthermore, a \emph{context} is defined as a list $Γ$ of
% context elements.



% -------------------------------------------------------- %
\subsection{The \textsc{LambdaPi} Proof Assistant}
%
\begin{boxfigure}[t!]{fig:lpSyntax}
	{Syntax for the \textsc{LambdaPi} proof assistant.}
	%
	$$ \lpTermsConcrete $$
	\hrule
	$$ \lpPatternSyntax $$
	\hrule
	$$ \lpConcreteSyntax $$
\end{boxfigure}
%
\Autoref{fig:lpSyntax} gives the syntax for a fragment of
the $\lambdapi$ proof assistant.
%
Note that the set of terms differs from that of the `pure'
$\lp$-calculus presented earlier.
%
The main differences are made to support \emph{implicit bindings},
which allow the user to omit some subterms and have them
automatically `inferred' by $\lambdapi$.
%
To facilitate this, abstractions now bind a \emph{parameter}
which may be either \emph{explicit} or \emph{implicit}
(written $\xpl{s : t}$ and $\imp{s : t}$ resp.),
and we have terms of the form $[t]$ which are
said to be \emph{explicated}.
%
Hereinafter, we may write $\prn{t_1 → t_2}$ for the term
$\prn{\ppii{(x : t_1)}{t_2}}$, where $x$ is some `fresh'
symbol that does not occur free in $t_2$.


We also introduce a syntax of \emph{patterns} which is
used within declarations of rewrite rules.
%
Each pattern is either a \emph{pattern variable}
$\prn{\ptrn{x}}$ or a \emph{pattern application}
$\prn{{s}\,{\any{p}}}$, where $s$ is called
the \emph{head} of the pattern.
%
Hereinafter, let $\pv(p)$ denote the set of
pattern variables occurring in some pattern $p$.

% ---------------------
A $\lambdapi$ \emph{file} is a list of \emph{commands},
which should be seen as a representation of a $\lp$-signature.
% Each command is either a \emph{symbol declaration}
% (\mtt{symbol}), \emph{rewrite rule declaration} (\mtt{rule}),
% or an \emph{import} (\mtt{require}).
%
To make this correspondence a bit clearer, the syntax
and behaviour of each command is discussed in the
following passages of text:

\subsubsection{Symbol Declaration.}
%
Each \emph{symbol declaration} consists of a symbol $s$,
a list of parameters $\vec ρ$, and a term $t$.
%
In general, this has the effect of adding
$\prn{s : \prn{\ppii{ρ_1}{\ldots\,\ppii{ρ_n}{t}}}}$
to the signature.
%
Optionally, a \emph{modifier} may be given.
The $\prn{\mtt{constant}}$ modifier forbids the user from later
adding rewrite rules with $s$ at the head, and
$\prn{\mtt{sequential}}$ alters the rewriting strategy of
$\lambdapi$ so that rewrite rules with head $s$
are `matched' in the order they are given in the file.
%
A \emph{definition} $\prn{{≔}\,t}$ may be given
when the $\prn{\mtt{constant}}$ modifier is not present,
which has the effect of adding the rewrite rule
$\prn{s\,\vec{ρ} ↪ t}$ to the signature.

\subsubsection{Rewrite Rule Declaration.}
%
Rewrite rules are introduced with the $\prn{\mtt{rule}}$
command.
For user convenience, a list of rewrite rules
may be introduced using the keyword $\prn{\mtt{with}}$.
%
In practice, a rewrite rule $\prn{p ↪ p'}$ will only be
accepted by $\lambdapi$ if $p$ is a pattern application
and $\pv(p') ⊆ \pv(p)$.
%
The rewrite rule(s) will be added to the signature in this
case, effectively augmenting the typechecking
procedure of $\lambdapi$ to behave `modulo' those rule(s).

\subsubsection{Theory Import.}
%
$\lambdapi$ uses a lightweight module system which allows
users to develop formalizations across multiple files,
possibly making use of third-party libraries.
%
Within this document, we use the command
$\prn{\mtt{require}\ \mtt{open}\ {\vec μ}}$
where $\vec μ$ is a list of $\prn{.}$-delimited \emph{paths}.
This command has the effect of importing all symbol
declarations and rewrite rules from the specified files.

\subsubsection{Type Universes.}
%
Because the type system of $\lambdapi$ does not allow
`quantifying' over types
(i.e., $\prn{\TYPE → \TYPE}$ is not well-typed),
most $\lambdapi$ developments make use of `Tarski-style'
universes to support treating types as `first-class citizens'.
%
In particular, we use the following symbol declarations:
%
$$
	\begin{array}[t]{l@{\ {:}\ }l}
		\mtt{symbol}\ \msf{Set} & \TYPE;                              \\
		%
		\mtt{symbol}\ \msf{El}  & \msf{Set} → \TYPE;                  \\
		%
		\mtt{symbol}\ \prn{⤳}   & \msf{Set} → \msf{Set} →  \msf{Set}; \\
	\end{array}
$$
%
We work `within' $\msf{Set}$ when embedding `many-sorted'
logics in $\lambdapi$. Namely, the translation outlined
in this document identifies Eunoia's types with terms of
type $\msf{Set}$ and uses $\msf{El}$ to `lift' these to
top-level $\lambdapi$ types.
%
Moreover, the (infix) symbol $\prn{⤳}$ is used as a
`set-level' type constructor, where the following rewrite
rule specifies how these sets are `lifted'.
%
$$
	\mtt{rule}\ \msf{El}\,\prn{\ptrn{α} ⤳ \ptrn{β}}
	\ {↪}\
	\prn{{\msf{El}\,\ptrn{α}} → {\msf{El}\,\ptrn{β}}};
$$


\subsubsection{Implicit Parameters.}
\label{sssec:lp-implicits}
%
As mentioned above, the presence of `implicit' bindings in
abstractions can enable the user to omit some terms in
applications, and have them automatically `inferred' by
$\lambdapi$.
%
This mechanism is particularly useful for implementing
\emph{type polymorphism}, where a function may have
different behaviours depending on the types of its arguments.
%
To make this notion more precise, consider the following
symbol declaration:
$$\mtt{symbol}\ \msf{foo}\ [α : \msf{Set}] : \Ell{α ⤳ α ⤳ α};$$
Modulo rewriting, the type of $\msf{foo}$ is
$\prn{
		\ppii{\imp{α : \Set}}{
			\El α → \El α → \El α
		}
	}$.
%
Because this type contains implicit bindings,
$\lambdapi$ also registers an `explicit version' of
$\msf{foo}$ named $\xsym{\msf{foo}}$ whose type
contains only explicit bindings.
%
Hereinafter, an application like
$\prn{\msf{foo}\,x\,y}$ generates a `schematic term'
$\prn{\xsym{\msf{foo}}\,\meta{α}\,x\,y}$
with constraints
$\{ \meta{α} : \Set,\, x : \El{\meta α},\, y : \El{\meta α} \}$.
%
Given a suitable context, $\lambdapi$ is able to `solve'
these constraints to infer a `concrete' value for $\meta α$.
%
% For example, given a context with
% $\prn{ℕ : \Set}$ and
% $\prn{x,y : \El ℕ}$ present,
% the term $\prn{\msf{foo}\,{x}\,{y}}$
% can be seen as `syntactic sugar'
% for $\prn{\xsym{\msf{foo}}\,ℕ\,x\,y}$.
%
Alternatively, a user can `force' values that would
otherwise be automatically inferred by using explicated
terms
(e.g.,
$\prn{\msf{foo}\,[ℕ]\,x\,y}$
is equivalent to
$\prn{\xsym{\msf{foo}}\,ℕ\,x\,y}$).

\end{document}
