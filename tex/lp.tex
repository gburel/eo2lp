\documentclass[class=llncs, crop=false]{standalone}
\input{preamble.tex}
\input{macros.tex}

\begin{document}

\begin{boxfigure}[t!]{fig:lpTermSyntax}
	{Syntax and typing rules for the $\lp$-calculus.}
	%
	$$\lpTermSyntax$$
	\hrule
	$$\lpTypingRules$$
	\hrule
	$$ \lpWfRules $$
	%
\end{boxfigure}
%
\Autoref{fig:lpTermSyntax} provides abstract syntax
for the \emph{$\lp$-calculus modulo rewriting}.
%
In particular, the rules in \autoref{fig:lpTermSyntax}
define the \emph{terms} of the $\lp$-calculus.
%
Each term is either a \emph{variable} $x$,
a \emph{constant} $κ$,
a \emph{universe} from $\{ \TYPE, \KIND \}$,
an \emph{application} of two terms $\prn{\app{t}{t'}}$,
or an \emph{abstraction}
$\prn{\binddot{\mscr{B}}{x : t}{t'}}$
where $\mscr{B}$ is a \emph{binder} from $\{ λ, Π \}$.
% TODO. define/declare α-conversion and β-reduction.
Terms are identified up to $α$-conversion
(i.e., renaming of bound variables), and we assume
the usual definitions for \emph{substitution} $\prn{t[x ↦ t']}$
and \emph{$β$-reduction} $\prn{t ⇝_{β} t'}$.

% --------------------------------------------------------%
% \begin{boxfigure}[t!]{fig:lpCtxSyntax}
% 	{Abstract syntax for $\lp$-contexts.}
% 	%
% 	$$\lpCtxSyntax$$
% 	%
% \end{boxfigure}
A \emph{typing} is an expression of the form $\prn{t : t'}$
for some terms $t$, $t'$, and a \emph{context} is a set of
typings of the form $\prn{x : t}$ for some variable $x$ and
term $t$.
%
Hereinafter, given a context $Γ$ and a typing $\prn{x : t}$,
let $\prn{Γ, \prn{x : t}}$ denote the extension $Γ ∪ \{x : t\}$.
%
A \emph{rewrite rule} is an expression of the form
$\prn{ℓ ↪ r}$, where $ℓ$ and $r$ are terms such that
$ℓ$ has the form
$\prn{\app{\prn{\app{κ}{t_1}} ⋅ \ldots}{t_n}}$
for some terms $\plur t n$.
% -------------------------------------------------------- %
% \begin{boxfigure}[t!]{fig:lpTypingRules}
% 	{Typing rules for the $\lp$-calculus.}
% 	%
% 	$$ \lpTypingRules $$
% 	\hrule
% 	$$ \lpWfRules $$
% \end{boxfigure}
% ----
A \emph{signature} is a set whose elements are either
typings or rewrite rules, where each typing
is of the form $\prn{κ : t}$ for some constant $κ$ and
term $t$.
%
Given some signature $Σ$, let $R_{Σ}$ be the smallest
binary relation such that:
%
\begin{enumerate}
	\item $\prn{ℓ ↪ r} ∈ Σ$ implies $(ℓ, r) ∈ R_{Σ}$, and
	\item $R_{Σ}$ is closed under application, abstraction,
	      and substitution.
\end{enumerate}
%
%, abstraction and substitution.  $R$
Then, \emph{equality modulo rewriting} $\prn{{≡_{Σ}}}$ is
defined as the least equivalence relation containing
$R_Σ$ and the $β$-reduction relation.
Furthermore, the rules in \autoref{fig:lpTermSyntax}
provide a (mutually inductive) definition of a
\emph{well-formedness} relation $\prn{\msf{wf}}$ on
contexts and a \emph{typing relation}
$\prn{⊢_{Σ}}$ between contexts and typings,
where $\prn{Γ ⊢_{Σ} e : t}$ may be read as
``$Γ$ proves $e$ has type $t$ with respect to $Σ$''.

% The rules in \autoref{fig:lpCtxSyntax} define
% a \emph{context element} $γ$ as either a \emph{typing}
% $\prn{x : t}$, or a \emph{rewrite rule} .
% %
% Furthermore, a \emph{context} is defined as a list $Γ$ of
% context elements.



% -------------------------------------------------------- %
\subsection{The \textsc{LambdaPi} Proof Assistant}
%
\begin{boxfigure}[t!]{fig:lpSyntax}
	{Concrete syntax for \textsc{LambdaPi}.}
	%
	$$ \lpTermsConcrete $$
	\hrule
	$$ \lpPatternSyntax $$
	\hrule
	$$ \lpConcreteSyntax $$
\end{boxfigure}
%
\Autoref{fig:lpSyntax} gives the syntax for a fragment of
the $\lambdapi$ proof assistant.
%
Note that the set of terms differs from that of the `pure'
$\lp$-calculus presented earlier.
%
The main differences are made to support \emph{implicit bindings},
which allow the user to omit some subterms and have them
automatically `inferred' by $\lambdapi$.
%
To facilitate this, abstractions now bind a \emph{parameter}
which may be either \emph{explicit} or \emph{implicit}
(written $\xpl{s : t}$ and $\imp{s : t}$ resp.),
and we have terms of the form $[t]$ which are
said to be \emph{explicated}.
%
Rewrite rules have a more restricted syntax using
\emph{patterns} where each pattern is either a
\emph{pattern variable} $\prn{\ptrn{x}}$,
or a \emph{pattern application} $\prn{{s}\,{\any{p}}}$
where $s$ is a symbol called the \emph{head} of the
pattern.
%


% ---------------------
A $\lambdapi$ \emph{file} is a list of \emph{commands},
which should be seen as a representation of a $\lp$-signature.
% Each command is either a \emph{symbol declaration}
% (\mtt{symbol}), \emph{rewrite rule declaration} (\mtt{rule}),
% or an \emph{import} (\mtt{require}).
%
To make this correspondence a bit clearer the, the syntax
and behaviour of each command is discussed in the
following passages of text:

\subsubsection{Symbol Declaration.}
%
Each \emph{symbol declaration} consists of a symbol $s$,
a list of parameters $\vec ρ$, and a term $t$.
%
In general, this has the effect of adding
$\prn{s : \prn{\ppii{ρ_1}{\ldots\,\ppii{ρ_n}{t}}}}$
to the signature.
%
Optionally, a \emph{modifier} may be given.
The $\mtt{constant}$ modifier forbids the user from later
adding rewrite rules with $s$ at the head, and
$\mtt{sequential}$ alters the rewriting engine of
$\lambdapi$ so that rewrite rules are `executed'
in the order they are given in the file.
%
A \emph{definition} $\prn{{≔}\,t}$ may be given
when the \mtt{constant} modifier is not present,
which has the effect of adding $\prn{s\,\vec{ρ} ↪ t}$
to the signature.

\subsubsection{Rewrite Rule Declaration.}
%
In practice, a rewrite rule $\prn{p ↪ p'}$ is only accepted
by $\lambdapi$ when $p$ is a pattern application and
$p'$ uses only those pattern variables occurring in $p$.
%
%
\subsubsection{Implicit Binding.}
%
Roughly, implicit binding


\begin{enumerate}
	\item The most primitive form of symbol declaration is
	      $\prn{\mtt{symbol}\ s\ {\plur ρ n} : t;}$, which
	      % has the effect

	\item A rewrite rule may be introduced by
	      $\prn{\mtt{rule}\ ℓ ↪ r;}$.
	      For user convenience, a list of rewrite rules
	      may be introduced using the \mtt{with}-syntax.

	\item Given an \emph{environment} $Θ$,
	      the contents of files named by $\plur μ n$
	      may be imported using the $\mtt{require}$ command.
	      %
	      By default, imported symbols are qualified by
	      the name of the file they were defined by.
	      That is, if $μ$ declares the symbol $s$
	      and $μ'$ imports $μ$, then the name of $s$ in $μ'$
	      is $\prn{μ.s}$.
\end{enumerate}

\subsubsection{Reconstruction of Implicit Parameters}
\label{sssec:lp-implicits}

\end{document}
