% font faces
\newcommand{\msf}{\mathsf}
\newcommand{\mbf}{\mathbf}
\newcommand{\mscr}{\mathscr}
\newcommand{\mtt}[1]{{\color{MaterialPink500}{\texttt{#1}}}}
\newcommand{\mcomment}[1]{{\color{MaterialIndigo500}{\text{#1}}}}
\newcommand{\wrapp}[4]{
	{\color{#1}{#2}}{#4}{\color{#1}{#3}}}
\newcommand{\prn}[1]{\wrapp{MaterialGrey600}{\lparen}{\rparen}{#1}}

% ----- abstract syntax ----------
% plurality, binding
\newcommand{\plur}[2]{{#1}_{1}\ldots{#1}_{#2}}
\newcommand{\plurcomma}[2]{{#1}_{1}, \ldots, {#1}_{#2}}
\newcommand{\maybe}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_?}{#1}}
\newcommand{\many}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_+}{#1}}
\newcommand{\any}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_∗}{#1}}
\newcommand{\some}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle}{#1}}
\newcommand{\binddot}[3]{{#1\,#2.\,#3}}

% binders
\newcommand{\lam}{\binddot{λ}}
\newcommand{\pii}{\binddot{Π}}
\newcommand{\alam}[1]{\binddot{\msf{λ}^{#1}}}
\newcommand{\apii}[1]{\binddot{\msf{Π}^{#1}}}
\newcommand{\lett}[2]{\msf{let}\ \prn{#1}\,\msf{in}\ #2}

% applications
\newcommand{\appSym}{\cdot}
\newcommand{\app}[2]{{#1}\appSym{#2}}
\newcommand{\apptwo}[3]{#1\,#2\,#3}
\newcommand{\appthree}[4]{#1\,#2\,#3\,#4}
\newcommand{\appfour}[5]{#1\,#2\,#3\,#4\,#5}
\newcommand{\appldots}[3]{((\app{#1}{#2})\,\ldots\,{#3})}

% universes
\newcommand{\PROP}{\mtt{prop}}
\newcommand{\TYPE}{\mtt{type}}
\newcommand{\KIND}{\mtt{kind}}

% sets for syntactic categories
\newcommand{\Term}{\msf{Term}}

% eunoia symbols
\newcommand{\eo}{\msf{eo}}
\newcommand{\sym}[1]{\msf{s}_{\msf{#1}}}
\newcommand{\eoapp}[2]{\prn{#1\ #2}}

% --- figures for `eoas.tex` ------------------------------
\newcommand{\eoTermSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l@{\qquad}r@{\ }l@{\quad}l}
		%!----------------------------------------!%
		s & {⦂}\ \sym 0 ∣ \sym 1 ∣ \ldots
		  & \mcomment{(symbols)}                  &
		e & {⦂}\ s \mid \prn{{s}\,\many{e}}
		  & \mcomment{(terms)}
		\\[1mm]
		ν & {⦂}\ \mtt{:implicit} \mid \mtt{:list}
		  & \mcomment{(var. attributes)}          &
		ρ & {⦂}\ \prn{s\ e\ \maybe{ν}}\qquad
		  & \mcomment{(parameters)}
		\\[1mm]
		α &
		\multicolumn{4}{@{}l}{
			\begin{array}[t]{@{}l@{\ }l@{\quad}r}
				{⦂} &
				\mtt{:right-assoc} ∣ \mtt{:right-assoc-nil}\some{t} \\
				{∣} &
				\mtt{:left-assoc} ∣ \mtt{:left-assoc-nil}\some{t}   \\
				{∣} &
				\mtt{:chainable}\some{s} ∣
				\mtt{:pairwise}\some{s} ∣
				\mtt{:binder}\some{s}
			\end{array}
		}
		  &
		\mcomment{(const. attributes)}
	\end{array}
}

\newcommand{\eoCommandSyntax}{
	\begin{array}[t]{r@{\ }l}
		δ
		 &
		\begin{array}[t]{c@{\ }l}
			{⦂} &
			\prn{\mtt{declare-const}\ s\ e\ α}
			\\
			{∣} & \prn{\mtt{declare-consts}\ ℓ\ e}
			\\
			{∣} &
			\prn{\mtt{declare-parameterized-const}\ s\ {\vec ρ}\ e\ α}
			\\
			{∣} &
			{\color{MaterialGrey600}{\big\lparen}}
			\mtt{declare-rule}\ s\ \any{ρ}\
			\\ & \quad
			\maybe{\mtt{:assumption}\,e}\
			\\ & \quad
			\maybe{\mtt{:premises}\,\any{φ}}\
			\\ & \quad
			\maybe{\mtt{:args}\,\any{e}}\
			\\ & \quad
			\maybe{\mtt{:requires}\,{\many{e,e'}}}\
			\\ & \quad
			\mtt{:conclusion}\,{ψ}
				{\color{MaterialGrey600}{\big\rparen}}
			\\
			{∣} &
			\prn{\mtt{declare-type}\ {s}\ \prn{\any e}}
			\\
			{∣} &
			\prn{\mtt{define}\ {s}
			\ \maybe{\vec ρ}
			\ e\
			\ \maybe{\mtt{:type}\,e'}}
			\\
			{∣} &
			\prn{\mtt{define-type}\ {s}
			\ \prn{\any e}
			\ e'}
			\\
			{∣} &
			\prn{\mtt{include}\ \some{\msf{string}}}
			\\
			{∣} &
			\prn{\mtt{program}\ x
				\ \any{ρ}
				\ \some{\mtt{:signature}\,\prn{\many{e}}\,e'}
				\ \prn{\many{e\ e'}}
			}
		\end{array}
	\end{array}}

\newcommand{\eoPrfCommandSyntax}{
	\begin{array}[t]{r@{\ }l}
		π
		 &
		\begin{array}[t]{c@{\ }l}
			{⦂} & \prn{\mtt{assume}\ s\ e}
			\\
			{∣} & \prn{\mtt{assume-push}\ s\ e}
			\\
			{∣} & \prn{\mtt{step}\ s\ \maybe{e}\
			\prn{\mtt{:rule}\ s_r}\
			\maybe{\mtt{:premises}\ {\vec φ}}\
			\maybe{\mtt{:args}\ {\vec e}}
			}
			\\
			{∣} & \prn{\mtt{step-pop}\ s\ \maybe{e}\
			\prn{\mtt{:rule}\ {s_r}}\
			\maybe{\mtt{:premises}\ {\vec φ}}\
			\maybe{\mtt{:args}\ {\vec e}}
			}
		\end{array}
	\end{array}}

% --- macros for `lp.tex` ------------------------------
\newcommand{\lp}{λΠ}
\newcommand{\var}[1]{\msf{v}_{#1}}
\newcommand{\lpTermSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		u & {⦂}\ \TYPE ∣ \KIND
		  & \mcomment{(universes)} \\
		% ------------------------------------- %
		t & {⦂}\ x ∣ κ ∣ u
		∣ \prn{\app{t}{t'}}
		∣ \prn{\lam{x : t}{t'}}
		∣ \prn{\pii{x : t}{t'}}
		  & \mcomment{(terms)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\lpCtxSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		γ & {⦂}\ \prn{x : t} \mid \prn{t ↪ t'}
		  & \mcomment{(context elements)}      \\
		% ------------------------------------- %
		Γ & {⦂}\ \any{γ}
		  & \mcomment{(contexts)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\judge}[3]{{#1} ⊢_{Σ} {#2} : {#3}}
\newcommand{\wf}[1]{\msf{wf}\,{#1}}
% typing rules
\newcommand{\typeRule}{
	\begin{prooftree}
		\hypo{\wf Γ}
		\infer1{ \judge Γ \TYPE \KIND }
	\end{prooftree}
}

\newcommand{\varRule}{
	\begin{prooftree}
		\hypo{ \wf Γ}
		\infer1[$\prn{x : t} ∈ Γ$]{ \judge Γ x t }
	\end{prooftree}
}

\newcommand{\constRule}{
	\begin{prooftree}
		\hypo{\wf Γ}
		\hypo{\judge Γ t u}
		\infer2[$\prn{κ : t} ∈ Σ$]{ \judge Γ κ t }
	\end{prooftree}
}

\newcommand{\prodRule}{
	\begin{prooftree}
		\hypo{\judge Γ t u}
		\hypo{\judge{Γ, \prn{x : t}}{t'}{u'}}
		\infer2{\judge Γ {\prn{\pii {x : t} {t'}}} {u'} }
	\end{prooftree}
}

\newcommand{\absRule}{
	\begin{prooftree}
		\hypo{\judge{Γ, \prn{x : t}} e {t'}}
		\hypo{\judge Γ {\prn{\pii {x : t} {t'}}} u}
		\infer2{\judge Γ
		{\prn{\lam {x : t} {e}}}
		{\prn{\pii {x : t} {t'}}}
		}
	\end{prooftree}
}

\newcommand{\appRule}{
	\begin{prooftree}
		\hypo{\judge Γ e {\prn{\pii{x : t}{t'}}}}
		\hypo{\judge Γ {e'} t}
		\infer2{\judge Γ {\prn{\app{e}{e'}}} {t'[x ↦ {e'}]}}
	\end{prooftree}
}

\newcommand{\convRule}{
	\begin{prooftree}
		\hypo{\judge Γ e t}
		\hypo{\judge Γ {t'} {u}}
		\infer2[$\prn{t ≡_{Σ} t'}$]{\judge Γ {e} {t'}}
	\end{prooftree}
}

\newcommand{\wfRuleEmp}{
	\begin{prooftree}
		\infer0{ \wf{\msf{∅}} }
	\end{prooftree}
}

\newcommand{\wfRuleVar}{
	\begin{prooftree}
		\hypo{ \judge Γ t u }
		\infer1{ \wf{(Γ, \prn{x : t})}}
	\end{prooftree}
}

\newcommand{\rname}[1]{\mcomment{($\textsc{#1}$)}}

\newcommand{\lpTypingRules}{
	\begin{array}[t]{c}
		\rname{typ}  \ {⦂}\ \  \typeRule  \\[4mm]
		\rname{con}  \ {⦂}\ \  \constRule \\[4mm]
		\rname{var}  \ {⦂}\ \  \varRule   \\[4mm]
		\rname{prod} \ {⦂}\ \  \prodRule  \\[4mm]
		\rname{fun}  \ {⦂}\ \  \absRule   \\[4mm]
		\rname{app}  \ {⦂}\ \  \appRule   \\[4mm]
		\rname{conv} \ {⦂}\ \  \convRule  \\[4mm]
	\end{array}
}

\newcommand{\lpWfRules}{
	\begin{array}[t]{c@{\qquad}c}
		\rname{wf0} \ \ {⦂}\ \  \wfRuleEmp
		 &
		\rname{wf+} \ \ {⦂}\ \  \wfRuleVar
	\end{array}
}

\newcommand{\lpConcreteSyntax}{
	\begin{array}[t]{r@{\ }c@{\ }l}
		c & {⦂} &
		\maybe{m}\, \mtt{symbol}\ s
		\ \any{ρ}
		\,{: t}
		\ \maybe{≔ t'};
		\\
		  & {∣} &
		\mtt{rule}\ r\
		\any{\mtt{with}\ r'};
		\\
		  & {∣} &
		\mtt{require}\ \maybe{\mtt{open}}\,\many{μ};
		\\[1mm]
		r & {⦂} &
		\prn{ {κ\,\any{t}} ↪ {\,t'}}
	\end{array}
	\qquad
	\begin{array}[t]{l@{\ }c@{\ }l}
		m & {⦂} & \mtt{constant}
		\\
		  & {∣} & \mtt{sequential}
		\\
		  & {∣} & \mtt{injective}
		\\[1mm]
		ρ & {⦂} & (x : t) ∣ [\,x : t\,]
	\end{array}}

\newcommand{\lambdapi}{\textsc{LambdaPi}}
% \newcommand{\symb}[1]{\mtt{symbol}\ {#1};}

% \newcommand{\symb}[1]{\mtt{rule}\ {#1};}
