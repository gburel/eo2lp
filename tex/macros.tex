% font faces
\newcommand{\msf}{\mathsf}
\newcommand{\mbf}{\mathbf}
\newcommand{\mscr}{\mathscr}
\newcommand{\mtt}[1]{{\color{MaterialPink500}{\texttt{#1}}}}
\newcommand{\ptn}[1]{{\color{MaterialPurple500}{\texttt{#1}}}}
\newcommand{\mcomment}[1]{{\color{MaterialIndigo500}{\text{#1}}}}
\newcommand{\wrapp}[4]{ {\color{#1}{#2}}{#4}{\color{#1}{#3}}}
\newcommand{\prn}[1]{\wrapp{MaterialGrey600}{\lparen}{\rparen}{#1}}

% ----- abstract syntax ----------
% plurality, binding
\newcommand{\plur}[2]{{#1}_{1}\ldots{#1}_{#2}}
\newcommand{\plurcomma}[2]{{#1}_{1}, \ldots, {#1}_{#2}}
\newcommand{\maybe}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_?}{#1}}
\newcommand{\many}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_+}{#1}}
\newcommand{\any}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_∗}{#1}}
\newcommand{\some}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle}{#1}}
\newcommand{\binddot}[3]{{#1\,#2.\,#3}}

% binders
\newcommand{\lam}{\binddot{λ}}
\newcommand{\pii}{\binddot{Π}}
\newcommand{\alam}[1]{\binddot{\msf{λ}^{#1}}}
\newcommand{\apii}[1]{\binddot{\msf{Π}^{#1}}}
\newcommand{\lett}[2]{\msf{let}\ \prn{#1}\,\msf{in}\ #2}

% applications
\newcommand{\appSym}{\cdot}
\newcommand{\app}[2]{{#1}\appSym{#2}}
\newcommand{\apptwo}[3]{#1\,#2\,#3}
\newcommand{\appthree}[4]{#1\,#2\,#3\,#4}
\newcommand{\appfour}[5]{#1\,#2\,#3\,#4\,#5}
\newcommand{\appldots}[3]{((\app{#1}{#2})\,\ldots\,{#3})}

% universes
\newcommand{\PROP}{\mtt{prop}}
\newcommand{\TYPE}{\mtt{type}}
\newcommand{\KIND}{\mtt{kind}}

% sets for syntactic categories
\newcommand{\Term}{\msf{Term}}

% eunoia symbols
\newcommand{\eo}{\msf{eo}}
\newcommand{\sym}[1]{\msf{s}_{\msf{#1}}}
\newcommand{\eoapp}[2]{\prn{#1\ #2}}
% --- figures for `eoas.tex` ------------------------------
% s & {⦂}\ \sym 0 ∣ \sym 1 ∣ \ldots
% 		& \mcomment{(symbols)}         &
%
\newcommand{\eoTermSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l@{\qquad}r@{\ }l@{\quad}l}
		%!----------------------------------------!%
		t & {⦂}\ s \mid \prn{{s}\,\many{t}}  & \mcomment{(terms)}      &
		ρ & {⦂}\ \prn{s\ t\ \maybe{ν}}\qquad & \mcomment{(parameters)}   \\[1mm]
	\end{array}
}

\newcommand{\eoAttrSyntax}{
	\begin{array}[t]{r@{\ }c@{\ }l@{\quad}l}
		ν & {⦂} & \mtt{:implicit} \mid \mtt{:list}                       & \mcomment{(var. attributes)}   \\[1mm]
		α & {⦂} & \mtt{:right-assoc} ∣ \mtt{:right-assoc-nil}\,\some{t}  & \mcomment{(const. attributes)} \\
		  & {∣} & \mtt{:left-assoc} ∣ \mtt{:left-assoc-nil}\,\some{t}                                     \\
		  & {∣} & \mtt{:chainable}\,\some{s} ∣ \mtt{:pairwise}\,\some{s}
	\end{array}
}

\newcommand{\eoCommandSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l}
		δ & \begin{array}[t]{c@{\ }l}
			    {⦂} & \prn{\mtt{declare-const}\ s\ t\ \maybe{α}}                              \\
			    {∣} & \prn{\mtt{declare-parameterized-const}\ s\ \prn{\vec{ρ}}\ t\ \maybe{α}} \\
			    {∣} & \prn{\mtt{define}\ {s} \ \prn{\vec ρ} \ t\ \ \maybe{\mtt{:type}\,t'}}   \\
			    {∣} & \prn{\mtt{program}\ x \ \prn{\vec ρ}\
				    \mtt{:signature}\,\prn{\vec{t}}\,t'\
				    \prn{\many{\prn{t_{l}\ t_{r}}}}
			    }                                                                             \\
			    {∣} & {\color{MaterialGrey600}{\lparen}}
			    \mtt{declare-rule}\ s\ \prn{\vec ρ}\
			    \\ & \quad \maybe{\mtt{:premises}\ \prn{\vec{t}_{\text{prems}}}}\
			    \\ & \quad \maybe{\mtt{:args}\ \prn{\vec{t}_{\text{args}}}}\
			    \\ & \quad \maybe{\mtt{:requires}\ \prn{\many{\prn{t_l\ t_r'}}}}\
			    \\ & \quad \mtt{:conclusion}\ {t_{\text{conc}}}
			    {\color{MaterialGrey600}{\rparen}}                                            \\
			    {∣} & \prn{\mtt{include}\ μ}                                                  \\
		    \end{array}
		  & \mcomment{(std. commands)}
	\end{array}
}

\newcommand{\eoPrfCommandSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l}
		π & \begin{array}[t]{c@{\ }l}{⦂} & \prn{\mtt{assume}\ s\ e} \\ {∣} & \prn{\mtt{assume-push}\ s\ e} \\ {∣} & \prn{\mtt{step}\ s\ \maybe{e}\
             \prn{\mtt{:rule}\ s_r}\
             \maybe{\mtt{:premises}\ {\vec φ}}\
             \maybe{\mtt{:args}\ {\vec e}} }            \\ {∣} & \prn{\mtt{step-pop}\ s\ \maybe{e}\
             \prn{\mtt{:rule}\ {s_r}}\
             \maybe{\mtt{:premises}\ {\vec φ}}\
             \maybe{\mtt{:args}\ {\vec e}} }
		    \end{array}
		  & \mcomment{(proof commands)}
	\end{array}}

% --- macros for `lp.tex` ------------------------------
\newcommand{\lp}{λΠ}
\newcommand{\var}[1]{\msf{v}_{#1}}
\newcommand{\lpTermSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		u & {⦂}\ \TYPE ∣ \KIND
		  & \mcomment{(universes)}                                                             \\
		% ------------------------------------- %
		t & {⦂}\ x ∣ κ ∣ u ∣ \prn{\app{t}{t'}} ∣ \prn{\lam{x : t}{t'}} ∣ \prn{\pii{x : t}{t'}}
		  & \mcomment{(terms)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\lpCtxSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		γ & {⦂}\ \prn{x : t} \mid \prn{t ↪ t'} \
		  & \mcomment{(context elements)}        \\
		% ------------------------------------- %
		Γ & {⦂}\ \any{γ}
		  & \mcomment{(contexts)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\judge}[3]{{#1} ⊢_{Σ} {#2} : {#3}}
\newcommand{\wf}[1]{\msf{wf}\,{#1}}
% typing rules
\newcommand{\typeRule}{
	\begin{prooftree}
		\hypo{\wf Γ}
		\infer1{ \judge Γ \TYPE \KIND }
	\end{prooftree}
}

\newcommand{\varRule}{
	\begin{prooftree}
		\hypo{ \wf Γ}
		\infer1[$\prn{x : t}∈ Γ$]{ \judge Γ x t }
	\end{prooftree}
}

\newcommand{\constRule}{
	\begin{prooftree}
		\hypo{\wf Γ}
		\hypo{\judge Γ t u}
		\infer2[$\prn{κ : t}∈ Σ$]{ \judge Γ κ t }
	\end{prooftree}
}

\newcommand{\prodRule}{
	\begin{prooftree}
		\hypo{\judge Γ t {\TYPE}}
		\hypo{\judge{Γ, \prn{x : t}}{t'}{u'}}
		\infer2{\judge Γ {\prn{\pii {x : t} {t'}}} {u'} }
	\end{prooftree}
}

\newcommand{\absRule}{
	\begin{prooftree}
		\hypo{\judge{Γ, \prn{x : t}} e {t'}}
		\hypo{\judge Γ {\prn{\pii {x : t} {t'}}} u}
		\infer2{\judge Γ {\prn{\lam {x : t} {e}}} {\prn{\pii {x : t} {t'}}} }
	\end{prooftree}
}

\newcommand{\appRule}{
	\begin{prooftree}
		\hypo{\judge Γ e {\prn{\pii{x : t}{t'}}}}
		\hypo{\judge Γ {e'} t}
		\infer2{\judge Γ {\prn{\app{e}{e'}}} {t'[x ↦ {e'}]}}
	\end{prooftree}
}

\newcommand{\convRule}{
	\begin{prooftree}
		\hypo{\judge Γ e t}
		\hypo{\judge Γ {t'} {u}}
		\infer2[$\prn{t ≡_{Σ} t'}$]{\judge Γ {e} {t'}}
	\end{prooftree}
}

\newcommand{\wfRuleEmp}{
	\begin{prooftree}
		\infer0{ \wf{\msf{∅}} }
	\end{prooftree}
}

\newcommand{\wfRuleVar}{
	\begin{prooftree}
		\hypo{ \judge Γ t u }
		\infer1{ \wf{(Γ, \prn{x : t})}}
	\end{prooftree}
}

\newcommand{\rname}[1]{\mcomment{($\textsc{#1}$)}}

\newcommand{\lpTypingRules}{
	\begin{array}[t]{c}
		\rname{typ} \ {⦂}\ \  \typeRule  \\[4mm]
		\rname{con} \ {⦂}\ \  \constRule \\[4mm]
		\rname{var} \ {⦂}\ \  \varRule   \\[4mm]
		\rname{prod} \ {⦂}\ \  \prodRule \\[4mm]
		\rname{fun} \ {⦂}\ \  \absRule   \\[4mm]
		\rname{app} \ {⦂}\ \  \appRule   \\[4mm]
		\rname{conv} \ {⦂}\ \  \convRule \\[4mm]
	\end{array}
}

\newcommand{\lpWfRules}{
	\begin{array}[t]{c@{\qquad}c}
		\rname{wf0} \ \ {⦂}\ \  \wfRuleEmp
		 & \rname{wf+} \ \ {⦂}\ \  \wfRuleVar
	\end{array}
}


% --- concrete syntax for lambdapi
\newcommand{\lambdapi}{\textsc{LambdaPi}}
\newcommand{\llam}{\binddot{\msf{λ}}}
\newcommand{\ppii}{\binddot{\msf{Π}}}

\newcommand{\prm}[1]{\mbf{#1}}
\newcommand{\xsym}[1]{\mtt{@}{#1}}
\newcommand{\meta}[1]{\ptn{?{#1}}}

\newcommand{\ptrn}[1]{\ptn{\$#1}}
\newcommand{\pv}{\mbf{pvars}}

\newcommand{\imp}[1]{[#1]}
\newcommand{\xpl}[1]{\left(#1\right)}

\newcommand{\lpTermsConcrete}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		ρ & {⦂}\,\xpl{s : t} ∣ \imp{s : t}
		  & \mcomment{(parameters)}
		\\[1mm]
		t & {⦂}\ s ∣ \imp{t} ∣ \prn{\app{t}{t'}}
		∣ \prn{\llam{ρ}{t}} ∣ \prn{\ppii{ρ}{t}}
		  & \mcomment{(terms)}
	\end{array}
}


\newcommand{\lpPatternSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		θ & {⦂}\ \ptrn{x} ∣ s\,\any{θ}
		  & \mcomment{(patterns)}
		\\[1mm]
		r & {⦂}\ \prn{{s\,\any{θ}} ↪ {θ'}}
		  & \mcomment{(rewrite rules)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\lpConcreteSyntax}{
	\begin{array}[t]{r@{\ }c@{\ }l@{\quad}r}
		m & {⦂}
		  & \mtt{constant} ∣ \mtt{sequential} ∣ \mtt{injective}
		  & \mcomment{(modifiers)}
		\\[1mm]
		c & {⦂}
		  & \maybe{m}\, \mtt{symbol}\ s \ \any{ρ} \,{: t} \ \maybe{≔ t'};
		  & \mcomment{(commands)}
		\\
		  & {∣}
		  & \mtt{rule}\ r\ \any{\mtt{with}\ r'};
		\\
		  & {∣}
		  & \mtt{require}\,\mtt{open}\,\many{μ};
	\end{array}}

% \newcommand{\symb}[1]{\mtt{symbol}\ {#1};}

% \newcommand{\symb}[1]{\mtt{rule}\ {#1};}

\newcommand{\Set}{\msf{Set}}
\newcommand{\El}[1]{\msf{El}\,{#1}}
\newcommand{\Ell}[1]{\msf{El}\,\prn{#1}}
