% font faces
\newcommand{\msf}{\mathsf}
\newcommand{\mbf}{\mathbf}
\newcommand{\mscr}{\mathscr}
\newcommand{\mtt}[1]{{\color{MaterialPink500}{\texttt{#1}}}}
\newcommand{\ev}[1]{{\color{MaterialGrey800}{\texttt{#1}}}}

\newcommand{\tsm}[1]{{\small\text{#1}}}

\newcommand{\ptn}[1]{{\color{MaterialPurple500}{\texttt{#1}}}}
\newcommand{\mcomment}[1]{{\color{MaterialIndigo500}{\text{#1}}}}
\newcommand{\wrapp}[4]{{\color{#1}{#2}}{#4}{\color{#1}{#3}}}
\newcommand{\prn}[1]{\wrapp{MaterialGrey600}{\lparen}{\rparen}{#1}}

\newcommand{\cvc}[1]{\textsc{cvc{#1}}}
\newcommand{\verit}{\textsc{veriT}}
\newcommand{\eunoia}{\textsc{Eunoia}}

% ----- abstract syntax ----------
% plurality, binding
\newcommand{\plur}[2]{{#1}_{1}\ldots{#1}_{#2}}
\newcommand{\plurcomma}[2]{{#1}_{1}, \ldots, {#1}_{#2}}
\newcommand{\maybe}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_?}{#1}}
\newcommand{\many}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_+}{#1}}
\newcommand{\any}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle_∗}{#1}}
\newcommand{\some}[1]{\wrapp{MaterialGrey600}{\langle}{\rangle}{#1}}
\newcommand{\binddot}[3]{{#1\,#2.\,#3}}

% binders
\newcommand{\lam}{\binddot{λ}}
\newcommand{\pii}{\binddot{Π}}
\newcommand{\alam}[1]{\binddot{\msf{λ}^{#1}}}
\newcommand{\apii}[1]{\binddot{\msf{Π}^{#1}}}
\newcommand{\lett}[2]{\msf{let}\ \prn{#1}\,\msf{in}\ #2}

% applications
\newcommand{\appSym}{\cdot}
\newcommand{\app}[2]{{#1}\appSym{#2}}
\newcommand{\apptwo}[3]{#1\,#2\,#3}
\newcommand{\appthree}[4]{#1\,#2\,#3\,#4}
\newcommand{\appfour}[5]{#1\,#2\,#3\,#4\,#5}
\newcommand{\appldots}[3]{((\app{#1}{#2})\,\ldots\,⋅\,{#3})}

% universes
\newcommand{\PROP}{\mtt{prop}}
\newcommand{\TYPE}{\mtt{type}}
\newcommand{\KIND}{\mtt{kind}}



% -------------- Eunoia ------------------------------------
% eunoia symbols
\newcommand{\epar}[1]{\wrapp{MaterialGrey600}{\texttt{(}}{\texttt{)}}{#1}}
\newcommand{\eapp}[2]{\epar{#1\ #2}}
\newcommand{\earr}[1]{\epar{\mtt{->}\ #1}}

\newcommand{\sym}[1]{\msf{s}_{\msf{#1}}}
% \newcommand{\eoapp}[2]{\prn{#1\ #2}}
% \newcommand{\earr}[1]{\mtt{#1}}
\newcommand{\ctyp}{\mbf{ctyp}}
\newcommand{\att}{\mbf{att}}

\newcommand{\prf}{\mbf{prf}}
\newcommand{\step}{\mbf{step}}

\newcommand{\eor}{\mtt{or}}
\newcommand{\econcat}[3]{\eapp{\mtt{eo::concat}}{#1\ #2\ #3}}
\newcommand{\econs}[3]{\eapp{#1}{#2\ #3}}
\newcommand{\false}{\mtt{false}}

\newcommand{\rcn}[1]{\mtt{:right-assoc-nil}\ {#1}}
\newcommand{\rc}{\mtt{:right-assoc}}

\newcommand{\lcn}[1]{\mtt{:left-assoc-nil}\ {#1}}
\newcommand{\lc}{\mtt{:left-assoc}}


\newcommand{\nil}{{\text{nil}}}
\newcommand{\foldl}{\mbf{foldl}}
\newcommand{\foldr}{\mbf{foldr}}
\newcommand{\elab}[1]{\mbf{elab}_{\prn{#1}}}
\newcommand{\glue}[1]{\mbf{glue}_{\prn{#1}}}
\newcommand{\bool}{\mtt{Bool}}
% ---- eo commands ------
\newcommand{\dc}[2]{\epar{\mtt{declare-const}\ {#1}\ {#2}}}
\newcommand{\dca}[3]{\epar{\mtt{declare-const}\ {#1}\ {#2}\ {#3}}}

% --- figures for `eoas.tex` ------------------------------
% s & {⦂}\ \sym 0 ∣ \sym 1 ∣ \ldots
% 		& \mcomment{(symbols)}         &
%
\newcommand{\eoTermSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l@{\qquad}r@{\ }l@{\quad}l}
		%!----------------------------------------!%
		t & {⦂}\ s \mid \eapp{s}{\vec t} & \mcomment{(terms)}      &
		ρ & {⦂}\ \epar{s\ t\ \maybe{ν}}  & \mcomment{(parameters)}   \\[1mm]
	\end{array}
}

\newcommand{\eoAttrSyntax}{
	\begin{array}[t]{r@{\ }c@{\ }l@{\quad}l}
		ν & {⦂} & \mtt{:implicit} \mid \mtt{:list}                       & \mcomment{(var. attributes)}   \\[1mm]
		α & {⦂} & \mtt{:right-assoc} ∣ \mtt{:right-assoc-nil}\,\some{t}  & \mcomment{(const. attributes)} \\
		  & {∣} & \mtt{:left-assoc} ∣ \mtt{:left-assoc-nil}\,\some{t}                                     \\
		  & {∣} & \mtt{:chainable}\,\some{s} ∣ \mtt{:pairwise}\,\some{s}
	\end{array}
}

\newcommand{\eoCommandSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l}
		r & \begin{array}[t]{c@{\ }l}
			    {⦂} & \epar{t\ t'}
		    \end{array}
		  & \mcomment{(term pairs)}
		\\[1mm]
		δ & \begin{array}[t]{c@{\ }l}
			    {⦂} & \epar{\mtt{declare-const}\ s\ t\ \maybe{α}}                               \\
			    {∣} & \epar{\mtt{declare-parameterized-const}\ s\ \epar{\vec{ρ}}\ t\ \maybe{α}} \\
			    {∣} & \epar{\mtt{define}\ {s} \ \epar{\vec ρ} \ t\ \ \maybe{\mtt{:type}\,t'}}   \\
			    {∣} & \epar{\mtt{program}\ {s} \ \epar{\vec ρ}\
			    \mtt{:signature}\,\epar{\vec{t}}\,t'\
			    \epar{\vec{r}}
			    }                                                                               \\
			    {∣} & {\color{MaterialGrey600}{\texttt{(}}}
			    \mtt{declare-rule}\ s\ \epar{\vec ρ}\
			    \\ & \quad \maybe{\mtt{:premises}\ \epar{\vec{t}_{\text{prem}}}}\
			    \\ & \quad \maybe{\mtt{:args}\ \epar{\vec{t}_{\text{args}}}}\
			    \\ & \quad \maybe{\mtt{:requires}\ \epar{\vec{r}}}\
			    \\ & \quad \mtt{:conclusion}\ {t_{\text{conc}}}
			    {\color{MaterialGrey600}{\texttt{)}}}                                           \\
			    {∣} & \epar{\mtt{include}\ μ}
		    \end{array}
		  & \mcomment{(std. commands)}
	\end{array}
}

\newcommand{\eoPrfCommandSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}l}
		π & \begin{array}[t]{c@{\ }l}
		    {⦂} & \epar{\mtt{assume}\ s\ φ}       \\
			    % {∣} & \prn{\mtt{assume-push}\ s\ e}      \\
			   {∣} & \epar{\mtt{step}\ s\ φ\
			    \some{\mtt{:rule}\ s'}\
			    \maybe{\mtt{:premises}\ {\vec ψ}}\
			    \maybe{\mtt{:args}\ {\vec t}}}\\
			    % {∣} & \prn{\mtt{step-pop}\ s\ \maybe{e}\
			    % \prn{\mtt{:rule}\ {s_r}}\
			    % \maybe{\mtt{:premises}\ {\vec φ}}\
			    % \maybe{\mtt{:args}\ {\vec e}} }
		    \end{array}
		  & \mcomment{(prf. commands)}
	\end{array}
}

% --- macros for `lp.tex` ------------------------------
\newcommand{\esc}[1]{\wrapp{MaterialGrey600}{⦃}{⦄}{#1}}
\newcommand{\var}[1]{\msf{v}_{#1}}
\newcommand{\lbl}[2]{\rname{#1}\quad{#2}}
\newcommand{\lpTermSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		μ & {⦂}\ \TYPE ∣ \KIND
		  & \mcomment{(universes)}                                                             \\
		% ------------------------------------- %
		t & {⦂}\ x ∣ κ ∣ μ ∣ \prn{\app{t}{t'}} ∣ \prn{\lam{x : t}{t'}} ∣ \prn{\pii{x : t}{t'}}
		  & \mcomment{(terms)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\lpCtxSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		γ & {⦂}\ \prn{x : t} \mid \prn{t ↪ t'} \
		  & \mcomment{(context elements)}        \\
		% ------------------------------------- %
		Γ & {⦂}\ \any{γ}
		  & \mcomment{(contexts)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\judge}[3]{{#1} ⊢_{Σ} {#2} : {#3}}
\newcommand{\wf}[1]{\msf{wf}\,{#1}}
% typing rules
\newcommand{\typeRule}{
	\begin{prooftree}
		\hypo{\wf Γ}
		\infer1{ \judge Γ \TYPE \KIND }
	\end{prooftree}
}

\newcommand{\varRule}{
	\begin{prooftree}
		\hypo{ \wf Γ}
		\infer1[$\prn{x : t}∈ Γ$]{ \judge Γ x t }
	\end{prooftree}
}

\newcommand{\constRule}{
	\begin{prooftree}
		\hypo{\wf Γ}
		\hypo{\judge {} t μ}
		\infer2[$\prn{κ : t}∈ Σ$]{ \judge Γ κ t }
	\end{prooftree}
}

\newcommand{\prodRule}{
	\begin{prooftree}
		\hypo{\judge Γ t {\TYPE}}
		\hypo{\judge{Γ, \prn{x : t}}{t'}{μ'}}
		\infer2{\judge Γ {\prn{\pii {x : t} {t'}}} {μ'} }
	\end{prooftree}
}

\newcommand{\absRule}{
	\begin{prooftree}
		\hypo{\judge{Γ, \prn{x : t}} e {t'}}
		\hypo{\judge Γ {\prn{\pii {x : t} {t'}}} μ}
		\infer2{\judge Γ {\prn{\lam {x : t} {e}}} {\prn{\pii {x : t} {t'}}} }
	\end{prooftree}
}

\newcommand{\appRule}{
	\begin{prooftree}
		\hypo{\judge Γ e {\prn{\pii{x : t}{t'}}}}
		\hypo{\judge Γ {e'} t}
		\infer2{\judge Γ {\prn{\app{e}{e'}}} {t'[x ↦ {e'}]}}
	\end{prooftree}
}

\newcommand{\convRule}{
	\begin{prooftree}
		\hypo{\judge Γ e t}
		\hypo{\judge Γ {t'} {μ}}
		\infer2[$\prn{t ≡_{βΣ} t'}$]{\judge Γ {e} {t'}}
	\end{prooftree}
}

\newcommand{\wfRuleEmp}{
	\begin{prooftree}
		\infer0{ \wf{\msf{∅}} }
	\end{prooftree}
}

\newcommand{\wfRuleVar}{
	\begin{prooftree}
		\hypo{ \judge Γ t μ }
		\infer1[$x ∉ \mbf{dom}(Γ)$]{ \wf{(Γ, \prn{x : t})}}
	\end{prooftree}
}

\newcommand{\rname}[1]{\mcomment{($\textsc{#1}$)}}

\newcommand{\lpTypingRules}{
	\begin{array}[t]{c}
		\lbl{var}{\varRule}    \qquad  \lbl{con}{\constRule}
		\\[6mm]
		\lbl{univ}{\typeRule}  \qquad \lbl{prod}{\prodRule}
		\\[6mm]
		\lbl{fun}{\absRule} \\[6mm]
		\lbl{app}{\appRule} \\[6mm]
		\lbl{conv}{\convRule}
	\end{array}
}
\newcommand{\lpWfRules}{
	\begin{array}[t]{c}
		\lbl{wf0}{\wfRuleEmp}
		\qquad
		\lbl{wf+}{\wfRuleVar}
	\end{array}
}


% --- concrete syntax for lambdapi
\newcommand{\lambdapi}{\textsc{LambdaPi}}
\newcommand{\llam}{\binddot{\msf{λ}}}
\newcommand{\ppii}{\binddot{\msf{Π}}}

% \newcommand{\symbol}{\mtt{symbol}}

\newcommand{\prm}[1]{\mbf{#1}}
\newcommand{\xsym}[1]{\mtt{@}{#1}}
\newcommand{\meta}[1]{\ptn{?{#1}}}

\newcommand{\ptrn}[1]{\ptn{\$#1}}
\newcommand{\pv}{\mbf{pvars}}

\newcommand{\imp}[1]{[#1]}
\newcommand{\xpl}[1]{\left(#1\right)}

\newcommand{\lpTermsConcrete}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		ρ & {⦂}\,\xpl{s : t} ∣ \imp{s : t}
		  & \mcomment{(parameters)}
		\\[1mm]
		t & {⦂}\ s ∣ \imp{t} ∣ \prn{\app{t}{t'}}
		∣ \prn{\llam{ρ}{t}} ∣ \prn{\ppii{ρ}{t}}
		  & \mcomment{(terms)}
	\end{array}
}


\newcommand{\lpPatternSyntax}{
	\begin{array}[t]{r@{\ }l@{\quad}r}
		% ------------------------------------- %
		θ & {⦂}\ \ptrn{x} ∣ s\,\any{θ}
		  & \mcomment{(patterns)}
		\\[1mm]
		r & {⦂}\ \prn{{s\,\any{θ}} ↪ {θ'}}
		  & \mcomment{(rewrite rules)}
		% ------------------------------------- %
	\end{array}
}

\newcommand{\lpConcreteSyntax}{
	\begin{array}[t]{r@{\ }c@{\ }l@{\quad}r}
		m & {⦂}
		  & \mtt{constant} ∣ \mtt{sequential} ∣ \mtt{injective}
		  & \mcomment{(modifiers)}
		\\[1mm]
		c & {⦂}
		  & \maybe{m}\, \mtt{symbol}\ s \ \any{ρ} \,{: t} \ \maybe{≔ t'};
		  & \mcomment{(commands)}
		\\
		  & {∣}
		  & \mtt{rule}\ r\ \any{\mtt{with}\ r'};
		\\
		  & {∣}
		  & \mtt{require}\,\mtt{open}\,\many{μ};
	\end{array}}

% \newcommand{\symb}[1]{\mtt{symbol}\ {#1};}

% \newcommand{\symb}[1]{\mtt{rule}\ {#1};}

\newcommand{\Set}{\texttt{Set}}
\newcommand{\El}[1]{\texttt{El}\,{#1}}
\newcommand{\Ell}[1]{\texttt{El}\,\prn{#1}}

% ------- translation stuff -----------
\newcommand{\Term}{\msf{Term}}

%
\newcommand{\eo}{\msf{eo}}
\newcommand{\lp}{\msf{lp}}
\newcommand{\trans}[1]{\left⟦{#1}\right⟧}
\newcommand{\tm}[1]{\trans{#1}_\msf{tm}}
\newcommand{\ty}[1]{\trans{#1}_\msf{ty}}
\newcommand{\cmd}[1]{\trans{#1}_\msf{cmd}}
\newcommand{\ctx}[1]{\trans{#1}_\msf{ctx}}
