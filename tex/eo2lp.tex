\documentclass{llncs}

\usepackage{ebproof}
\usepackage{array}
\usepackage{unicode-math}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{xcolor-material}
\usepackage{hyperref}
\usepackage{newcomputermodern}

\usepackage{jbw-boxfigure}
\usepackage{jbw-fix-hyperref-autoref}

\title{%
  Automatically Translating Proof Systems
  for SMT Solvers to the λΠ-calculus}
\author{Ciarán Dunne, Guillaume Burel}
\institute{INRIA, ENS Paris-Saclay}

\usepackage[backend=biber]{biblatex}
\addbibresource{inria.bib}

\input{eo2lp.macros.tex}

\begin{document}
\maketitle
% we're not just translating proofs, but also the proof systems embedded in Eunoia.

\begin{abstract}
	\noindent
	Eunoia is a logical framework used for formally specifying the
	theories, inference rules, and derivations of SMT solvers with
	proof production facilities.
	%
	We present a tool \texttt{eo2lp}, for automatically translating Eunoia
	specifications and proofs into code for \texttt{lambdapi} ---
	an interactive theorem prover based on the $\lambda\Pi$-calculus.
	%
	Our approach is demonstrated by
	(a) translating the portion of \texttt{cvc5}'s
	\textit{co-operating proof calculus} (CPC) corresponding to the QF-UF
	fragment of SMT-LIB; and
	%
	(b) translating proofs produced by running \texttt{cvc5} on a set of
	QF-UF problems from the SMT-LIB benchmark library.
\end{abstract}

\section{Background}

The area of automated reasoning known as \emph{satisfiability modulo theories}
(SMT) is aimed primarily at developing tools for deciding the (un)satisfiability
of logical specifications from various mathematical theories~\cite{Barrett2021}.
%
When a specification is deemed to be unsatisfiable, many solvers are capable
of demonstrating this fact through the generation proof certificates.
%
Many proof formats exist (e.g., Alethe, LFSC), but the inference rules used
in their proofs are not specified in any formal language.
%
This can make the development of proof checkers challenging, as developers
must rewrite parts of their checker for every change made to the proof system.

\textit{Eunoia} is a logical framework that allows formalizing the inference
rules used by the proof production facilities of an SMT solver.
%
\textit{Ethos} is a C++ tool for verifying proofs in the Eunoia format.

% eunoia is similar/inspired by the speculative proposal for SMT-LIB 3.
SMT-LIB is a specification language used for interacting with SMT solvers.
The syntax and semantics of SMT-LIB are standardized by the
SMT-LIB Initiative~\autocite{Barrett2015-standard}).
%
Generally speaking, SMT-LIB scripts specify satisfiability problems for
many-sorted first-order logic (MFOL) and provide instructions for solvers
to interact with these specifications.


\section{Eunoia}

% we won't bother showing the formal details of the datatype used for eunoia
% concrete syntax. we'll just write the concrete syntax with metavariables
% inside.. we will justify this treatment by explaining our parser, lexer.
%
% but we will still develop an abstract notion of 'eunoia signature' etc.
The overall architecture of our method is as follows:
\begin{itemize}
	\item We parse Eunoia files using an \texttt{ocamllex} lexer and a parser
	      generated by \texttt{menhir}. The grammar used for generating the
	      parser is largely based off the grammar in the Eunoia user manual.

	\item We translate Eunoia specifications to an abstract syntax given by an
	      OCaml datatype. During this phase, we eliminate applications of
	      operators declared to be $n$-ary (e.g., \texttt{and}, \texttt{or}).
\end{itemize}

\section{Interpreting Eunoia in the λΠ-calculus}

\newcommand{\kon}[1]{\msf{k}_{\msf{#1}}}

\subsection{Terms, Judgements, and Inferences}
%

% TODO. fix \typecolon. seperate grammar for judgements, rewrite rules, signatures, ...
\begin{boxfigure}[t!]{fig:term-syntax}
	{Abstract syntax for Eunoia terms, contexts, and judgements.}
	$$
		\begin{array}[t]{c@{\quad}c}
			\begin{array}[t]{r@{\ }l@{\quad}l}
				%!----------------------------------------!%
				x,y,z & {⦂}\ \var 0 ∣ \var 1 ∣ \var 2 ∣ \ldots
				      & \mcomment{(variables)}                 \\[1mm]

				%------------------------------------------%
				e, t  &
				\begin{array}[t]{c@{\ }l}
					{⦂} & x ∣ u ∣ \paren{\app{e}{\paren{\plur t n}}} \\
					∣   & \paren{\lett{x ≔ t}{e}}                    \\
					∣   & \paren{\alam{ν}{x : t}{e}}                 \\
					∣   & \paren{\apii{ν}{x : t}{e}}                 \\
				\end{array}
				      & \mcomment{(terms)}
				%!----------------------------------------!%
			\end{array}
			 &
			\begin{array}[t]
				{r@{\ }l@{\quad}l}
				%------------------------------------------%
				u & {⦂}\ {\TYPE ∣ \KIND}
				  & \mcomment{(universes)}       \\[1mm]
				%------------------------------------------%
				ν &
				\begin{array}[t]{c@{\ }l}
					{⦂} & \mtt{implicit} \\
					∣   & \mtt{list}     \\
					∣   & \mtt{null}
				\end{array}
				  & \mcomment{(var. attributes)}
				% \\[2mm]
				%------------------------------------------%
				% ρ &
				% \begin{array}[t]{c@{\ }l}
				% 	{⦂} & ((x : t) ∷ ν)
				% \end{array}
				%   & \mcomment{(parameters)}
				% %------------------------------------------%
			\end{array}
		\end{array}
	$$
	\hrule
	\vspace{2mm}
	$$
		\begin{array}{r@{\ ⦂ \ }l@{\quad}r@{\qquad}r@{\ ⦂ \ }l@{\quad}r@{}}
			γ &
			\multicolumn{4}{@{}l@{}}{
			\paren{t_1 : t_2}
			\mid \paren{\paren{t_1 ≡ t_2} : t_3}
			}
			  & \mcomment{(context elements)}
			\\[1mm]
			Γ & \plur γ n
			  & \mcomment{(contexts)}
			  &
			j & Γ ⊢ γ
			  & \mcomment{(judgements)}
		\end{array}
	$$
\end{boxfigure}
%
Let $\Term$ be the set of \emph{terms} given by the language generated by the
non-terminal $t$ with the production rules given in \autoref{fig:term-syntax}.
%
Each term is either a \emph{variable},
a \emph{universe} from the set $\{ \TYPE, \KIND \}$,
an \emph{application} of two terms $\paren{\app{t_1}{t_2}}$,
a \emph{local definition} $\paren{\lett{x ≔ t_1}{t_2}}$,
or an \emph{abstraction} $\paren{\binddot{\mscr{B}^{ν}}{x : t_1}{t_2}}$,
where $\mscr{B}$ is a \emph{binder} from the set of symbols $\{ λ, Π \}$,
and $ν$ is a \emph{variable attribute}.

%
A \emph{context element} is either a \emph{typing} $\paren{t_1 : t_2}$,
a \emph{(typed) equality} $\paren{\paren{t_1 ≡ t_2} : t_3}$,
or a \emph{rewrite rule} $\paren{t_1 ↪ t_2}$.
%
A \emph{context} consists of a list $Γ$ of context elements, and
a \emph{judgement} $\paren{Γ ⊢ γ}$ consists of a context and a context element.
%


% $\attr(x)$ is a variable attribute when $x$ is a variable, and
% $\attr(κ)$ is a constant attribute when $κ$ is a constant.
\newcommand{\decl}[4]{\msf{decl}\,{#1}\,{#2}\,{#3}\,{#4}}
\newcommand{\defn}[3]{\msf{defn}\,{#1}\,{#2}\,{#3}}
\newcommand{\prog}[4]{\msf{prog}\,{#1}\,{#2}\,{#3}\,{#4}}
\newcommand{\irule}[5]{\msf{rule}\,{#1}\,{#2}\,{#3}\,{#4}\,{#5}}

\begin{boxfigure}[t]{fig:sig-syntax}
	{Abstract syntax for Eunoia signature declarations.}
	%
	$$
		\begin{array}[t]{r@{\ }l@{\quad}l}
			ρ &
			{⦂}\ \paren{x ∷ \paren{t,ν}}\quad\mcomment{(parameters)}\qquad
			r ⦂ \paren{t ↪ t'}
			  & \mcomment{(rewrite clauses)}   \\[1mm]
			%
			α &
			\begin{array}[t]{c@{\ }l}
				{⦂}  &
				\mtt{right-assoc} \mid
				\mtt{right-assoc-nil}\paren{t}
				\\
				\mid &
				\mtt{left-assoc} \mid
				\mtt{left-assoc-nil}\paren{t}
				\\
				\mid &
				\mtt{chainable}\paren{t} ∣
				\mtt{pairwise}\paren{t} ∣
				\mtt{null}
			\end{array}
			  & \mcomment{(const. attributes)} \\[5mm]
			%
		\end{array}
	$$
	\hrule
	$$\begin{array}{r@{\ }l@{\quad}l}
			δ &
			\begin{array}[t]{c@{\ }l}
				{⦂} & \paren{\decl{x}{\paren{\vec ρ}}{\paren{{:}\ t}}{\paren{{∷}\ α}}}
				∣ \paren{\defn{x}{\paren{\vec ρ}}{\paren{{≔}\ t}}{\paren{{:}\ t'}}}    \\
				{∣} & \paren{\prog{x}
				{\paren{\vec ρ}}
				{\paren{{:}\ {\paren{t_1 \ldots t_n} → t'}}}
				{\paren{r_1 \ldots r_m}}
				}                                                                      \\
				{∣} & \paren{\irule{x}
					{\paren{\vec ρ}}
					{\paren{φ_1 \ldots φ_n}}
					{\paren{t_1 \ldots t_m}}
					{\paren{ψ}}
				}
			\end{array}
			  & \mcomment{(declarations)}
		\end{array}
	$$
\end{boxfigure}
%
\Autoref{fig:sig-syntax} defines abstract syntax for
Eunoia signatures and their declarations.
%
A \emph{parameter} $\paren{x ∷ \paren{t,v}}$ is a variable
$x$ annotated with a term $t$ and a variable attribute $ν$.
%
A \emph{constant attribute} is any token generated by
the non-terminal $α$.

A \emph{(constant) declaration} consists of a
variable $x$, a list of parameters $\vec ρ$,
a term $t$, and a constant attribute $α$.
%
A \emph{(constant) definition} consists of a
variable $x$ and terms $t$, $t'$.
%
A \emph{program} consists of a
variable $x$, a list of parameters $\vec ρ$,
a \emph{signature} $(t_1, \ldots, t_n) → t'$,
and rewrite clauses $r_1,\ldots,r_m$.
%
A \emph{rule declaration} consists of a variable $x$,
a list of parameters $\vec ρ$,
a list of terms $\plur φ n$ called \emph{premises},
a list of terms $t_1, \ldots, t_n$ called \emph{argument patterns},
and a \emph{conclusion} $ψ$.


\printbibliography

\end{document}
