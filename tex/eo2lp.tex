\documentclass{llncs}

\usepackage{ebproof}
\usepackage{array}
\usepackage{unicode-math}
\usepackage{fontspec}
\usepackage{xcolor}
\usepackage{xcolor-material}
\usepackage{hyperref}
\usepackage{newcomputermodern}

\usepackage{jbw-boxfigure}
\usepackage{jbw-fix-hyperref-autoref}

\title{%
  Automatically Translating Proof Systems
  for SMT Solvers to the λΠ-calculus}
\author{Ciarán Dunne, Guillaume Burel}
\institute{INRIA, ENS Paris-Saclay}

\usepackage[backend=biber]{biblatex}
\addbibresource{inria.bib}

\input{eo2lp.macros.tex}

\begin{document}
\maketitle
% we're not just translating proofs, but also the proof systems embedded in Eunoia.

\begin{abstract}
	\noindent
	Eunoia is a logical framework used for formally specifying the
	theories, inference rules, and derivations of SMT solvers with
	proof production facilities.
	%
	We present a tool \texttt{eo2lp}, for automatically translating Eunoia
	specifications and proofs into code for \texttt{lambdapi} ---
	an interactive theorem prover based on the $\lambda\Pi$-calculus.
	%
	Our approach is demonstrated by
	(a) translating the portion of \texttt{cvc5}'s
	\textit{co-operating proof calculus} (CPC) corresponding to the QF-UF
	fragment of SMT-LIB; and
	%
	(b) translating proofs produced by running \texttt{cvc5} on a set of
	QF-UF problems from the SMT-LIB benchmark library.
\end{abstract}

\section{Background}

The area of automated reasoning known as \emph{satisfiability modulo theories}
(SMT) is aimed primarily at developing tools for deciding the (un)satisfiability
of logical specifications from various mathematical theories~\cite{Barrett2021}.
%
When a specification is deemed to be unsatisfiable, many solvers are capable
of demonstrating this fact through the generation proof certificates.
%
Many proof formats exist (e.g., Alethe, LFSC), but the inference rules used
in their proofs are not specified in any formal language.
%
This can make the development of proof checkers challenging, as developers
must rewrite parts of their checker for every change made to the proof system.

\textit{Eunoia} is a logical framework that allows formalizing the inference
rules used by the proof production facilities of an SMT solver.
%
\textit{Ethos} is a C++ tool for verifying proofs in the Eunoia format.

% eunoia is similar/inspired by the speculative proposal for SMT-LIB 3.
SMT-LIB is a specification language used for interacting with SMT solvers.
The syntax and semantics of SMT-LIB are standardized by the
SMT-LIB Initiative~\autocite{Barrett2015-standard}).
%
Generally speaking, SMT-LIB scripts specify satisfiability problems for
many-sorted first-order logic (MFOL) and provide instructions for solvers
to interact with these specifications.


\section{Eunoia}
% ---------------------------------------------------------
\begin{boxfigure}[t!]{fig:term-syntax}
	{Syntax for Eunoia symbols, terms, and parameters, and attributes.}
	%
	$$ \eoTermSyntax $$
\end{boxfigure}
% ---------------------------------------------------------

% ---------------------------------------------------------
The syntax for Eunoia expressions is given in
\autoref{fig:term-syntax} and \autoref{fig:command-syntax}.
%
The rules in \autoref{fig:term-syntax} define sets of
expressions for the \emph{symbols}, \emph{terms}, \emph{attributes},
and \emph{parameters} of Eunoia.
%
Each symbol $s$ belongs to the countably infinite set
of tokens $\{\sym 0, \sym 1, \ldots \}$, and
each term $e$ is either a symbol, or an \emph{application}
$\eoapp {s} {\vec e}$ for some list of terms $\vec e$.
%
The non-terminals $ν$ and $α$ range over
\emph{variable attributes} and \emph{constant attributes}
respectively.
%
Each \emph{parameter} $ρ$ is an expression
consisting of a symbol, a term, and an optional variable attribute.
%

\subsection{Terms, Types and Attributes}
%
The \emph{built-in constants} of Eunoia are given by a fixed
subset of symbols and denoted by the following expressions:
$\mtt{Type}$ (the kind of all types),
$\mtt{->}$ (arrow-type constructor),
$\mtt{\_}$ (binary function application),
$\mtt{Bool}$ (the type of Boolean values),
$\mtt{true}$ and $\mtt{false}$ (terms of type \mtt{Bool}).

%
\begin{boxfigure}[t]{fig:command-syntax}
	{Syntax for top-level Eunoia commands.}
	%
	$$ \eoCommandSyntax $$
	$$ \eoPrfCommandSyntax $$
\end{boxfigure}
%
\subsection{Commands and Signatures}

\Autoref{fig:command-syntax} defines the syntax for Eunoia's
top-level \emph{commands}. The expressions generated by $δ$
are called \emph{standard} commands, and those generated
by $π$ are called \emph{proof commands}.
%
Hereinafter, a Eunoia \emph{signature} is a list $\vec δ$
of standard commands, and a Eunoia \emph{proof script} is a
list $\vec π$ of proof commands.
%
The operational meaning of each standard command is discussed
directly below, and the meaning of proof commands is discussed
in \autoref{sec:eo-proof}.
%
\subsubsection{Constant Declarations}
\subsubsection{Type Declarations and Definitions}
\subsubsection{Macros and Programs}
\subsubsection{Signature Inclusions}
%

\subsection{Rule Declarations and Proof Scripts}

% The overall architecture of our method is as follows:
% \begin{itemize}
% 	\item We parse Eunoia files using an \texttt{ocamllex} lexer and a parser
% 	      generated by \texttt{menhir}. The grammar used for generating the
% 	      parser is largely based off the grammar in the Eunoia user manual.

% 	\item We translate Eunoia specifications to an abstract syntax given by an
% 	      OCaml datatype. During this phase, we eliminate applications of
% 	      operators declared to be $n$-ary (e.g., \texttt{and}, \texttt{or}).
% \end{itemize}



\label{sec:eo-proof}

\section{Interpreting Eunoia in the λΠ-calculus}

\newcommand{\kon}[1]{\msf{k}_{\msf{#1}}}

\subsection{Terms, Judgements, and Inferences}
%


%
Let $\Term$ be the set of \emph{terms} given by the language generated by the
non-terminal $t$ with the production rules given in \autoref{fig:term-syntax}.
%
Each term is either a \emph{variable},
a \emph{universe} from the set $\{ \TYPE, \KIND \}$,
an \emph{application} of two terms $\paren{\app{t_1}{t_2}}$,
a \emph{local definition} $\paren{\lett{x ≔ t_1}{t_2}}$,
or an \emph{abstraction} $\paren{\binddot{\mscr{B}^{ν}}{x : t_1}{t_2}}$,
where $\mscr{B}$ is a \emph{binder} from the set of symbols $\{ λ, Π \}$,
and $ν$ is a \emph{variable attribute}.

%
A \emph{context element} is either a \emph{typing} $\paren{t_1 : t_2}$,
a \emph{(typed) equality} $\paren{\paren{t_1 ≡ t_2} : t_3}$,
or a \emph{rewrite rule} $\paren{t_1 ↪ t_2}$.
%
A \emph{context} consists of a list $Γ$ of context elements, and
a \emph{judgement} $\paren{Γ ⊢ γ}$ consists of a context and a context element.
%


% $\attr(x)$ is a variable attribute when $x$ is a variable, and
% $\attr(κ)$ is a constant attribute when $κ$ is a constant.
\newcommand{\decl}[4]{\msf{decl}\,{#1}\,{#2}\,{#3}\,{#4}}
\newcommand{\defn}[3]{\msf{defn}\,{#1}\,{#2}\,{#3}}
\newcommand{\prog}[4]{\msf{prog}\,{#1}\,{#2}\,{#3}\,{#4}}
\newcommand{\irule}[5]{\msf{rule}\,{#1}\,{#2}\,{#3}\,{#4}\,{#5}}

%
\Autoref{fig:sig-syntax} defines abstract syntax for
Eunoia signatures and their declarations.
%
A \emph{parameter} $\paren{x ∷ \paren{t,v}}$ is a variable
$x$ annotated with a term $t$ and a variable attribute $ν$.
%
A \emph{constant attribute} is any token generated by
the non-terminal $α$.

A \emph{(constant) declaration} consists of a
variable $x$, a list of parameters $\vec ρ$,
a term $t$, and a constant attribute $α$.
%
A \emph{(constant) definition} consists of a
variable $x$ and terms $t$, $t'$.
%
A \emph{program} consists of a
variable $x$, a list of parameters $\vec ρ$,
a \emph{signature} $(t_1, \ldots, t_n) → t'$,
and rewrite clauses $r_1,\ldots,r_m$.
%
A \emph{rule declaration} consists of a variable $x$,
a list of parameters $\vec ρ$,
a list of terms $\plur φ n$ called \emph{premises},
a list of terms $t_1, \ldots, t_n$ called \emph{argument patterns},
and a \emph{conclusion} $ψ$.


%

\printbibliography

\end{document}


% \hrule
% \vspace{2mm}
% $$
% 	\begin{array}{r@{\ ⦂ \ }l@{\quad}r@{\qquad}r@{\ ⦂ \ }l@{\quad}r@{}}
% 		γ &
% 		\multicolumn{4}{@{}l@{}}{
% 		\paren{t_1 : t_2}
% 		\mid \paren{\paren{t_1 ≡ t_2} : t_3}
% 		}
% 		  & \mcomment{(context elements)}
% 		\\[1mm]
% 		Γ & \plur γ n
% 		  & \mcomment{(contexts)}
% 		  &
% 		j & Γ ⊢ γ
% 		  & \mcomment{(judgements)}
% 	\end{array}
% $$
% 	\hrule
% $$\begin{array}{r@{\ }l@{\quad}l}
% 		δ &
% 		\begin{array}[t]{c@{\ }l}
% 			{⦂} & \paren{\decl{x}{\paren{\vec ρ}}{\paren{{:}\ t}}{\paren{{∷}\ α}}}
% 			∣ \paren{\defn{x}{\paren{\vec ρ}}{\paren{{≔}\ t}}{\paren{{:}\ t'}}}    \\
% 			{∣} & \paren{\prog{x}
% 			{\paren{\vec ρ}}
% 			{\paren{{:}\ {\paren{t_1 \ldots t_n} → t'}}}
% 			{\paren{r_1 \ldots r_m}}
% 			}                                                                      \\
% 			{∣} & \paren{\irule{x}
% 				{\paren{\vec ρ}}
% 				{\paren{φ_1 \ldots φ_n}}
% 				{\paren{t_1 \ldots t_m}}
% 				{\paren{ψ}}
% 			}
% 		\end{array}
% 		  & \mcomment{(declarations)}
% 	\end{array}
% $$
