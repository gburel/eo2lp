(include "../CompOp.eo")
; =============================================
;  Right-associative null-terminated operators
;
; The following functions work with right-associative symbols with a defined
; null terminator, i.e. attribute :right-assoc-nil.  Those behave somewhat
; similar to functional programming lists. Therefore, the symbol will typically
; be called `cons` in the following and its nil terminator will be `nil`.
; In the documentation below, we say that a term is an cons-list with children
; t1 ... tn if it is of the form (cons t1 ... tn) where n>0 or nil if n=0.
;
; =============================================

; program: $nary_is_subset
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c1 T1: The first term, assumed to be a cons-list.
; - c2 T1: The second term, assumed to be a cons-list.
; return: >
;   true if c1 is a subset of c2, e.g. all children of c1 are also children of
;   c2, or false otherwise.
(program-schema :right-assoc-nil $nary_is_subset
    ((T1 Type) (c T1) (t T1) (xs T1 :list) (cons (-> T1 T1 T1)) (nil T1))
    ((-> T1 T1 T1) T1 T1 T1) Bool
    (
        (($nary_is_subset cons nil (cons c xs) t) (eo::ite (eo::is_neg (eo::list_find cons t c)) false ($nary_is_subset cons nil xs t)))
        (($nary_is_subset cons nil nil t)         true)
    )
)

; define: $nary_is_eq_set
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c1 T1: The first term, assumed to be a cons-list.
; - c2 T1: The second term, assumed to be a cons-list.
; return: >
;   true if c1 is a subset of c2 and c2 is a subset of c1.
(define $nary_is_eq_set ((T1 Type :implicit) (cons (-> T1 T1 T1)) (nil T1) (c1 T1) (c2 T1))
  (eo::ite
    ($nary_is_subset cons nil c1 c2)
    ($nary_is_subset cons nil c2 c1)
    false))

; program: $nary_remove
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c T1: The term to find.
; - xs T1: The term to search in, assumed to be a cons-list.
; return: >
;   The result of removing the first occurrence of c from xs if it exists.
(program-schema :right-assoc-nil $nary_remove
    ((T1 Type) (c T1) (y T1) (xs T1 :list) (cons (-> T1 T1 T1)) (nil T1))
    ((-> T1 T1 T1) T1 T1 T1) T1
    (
        (($nary_remove cons nil c (cons c xs)) xs)
        (($nary_remove cons nil c (cons y xs)) (eo::cons cons y ($nary_remove cons nil c xs)))
        (($nary_remove cons nil c nil)         nil)
    )
)

; Helper for reverse
; program: $nary_reverse_rec
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c T1: The term to reverse, assumed to be a cons-list.
; - acc T1: The current accumulated reversal of elements we have processed.
; return: >
;   The result of prepending the reverse of c to acc.
(program-schema :right-assoc-nil $nary_reverse_rec
    ((T1 Type) (cons (-> T1 T1 T1)) (nil T1) (x T1) (xs T1 :list) (l T1 :list))
    ((-> T1 T1 T1) T1 T1 T1) T1
    (
        (($nary_reverse_rec cons nil (cons x xs) l) ($nary_reverse_rec cons nil xs (eo::cons cons x l)))
        (($nary_reverse_rec cons nil nil l)         l)
    )
)

; program: $nary_reverse
; args:
; - x T1: The term to reverse.
; return: >
;   The reverse of x. Assumes that x is the application of a :right-assoc-nil
;   function, otherwise returns x itself.
(program-schema :right-assoc-nil $nary_reverse
    ((T1 Type) (x T1) (xs T1 :list) (cons (-> T1 T1 T1)) (nil T1))
    (T1) T1
    (
        (($nary_reverse (cons x xs)) ($nary_reverse_rec cons nil (cons x xs) nil))
        (($nary_reverse x)           x)
    )
)

; program: $nary_is_prefix
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c1 T1: The first term, assumed to be a cons-list.
; - c2 T1: The second term, assumed to be a cons-list.
; return: true if c1 is a prefix of c2.
(program-schema :right-assoc-nil $nary_is_prefix
    ((T1 Type) (cons (-> T1 T1 T1)) (nil T1) (t T1) (c1 T1) (c2 T1) (xs1 T1 :list) (xs2 T1 :list))
    ((-> T1 T1 T1) T1 T1 T1) Bool
    (
        (($nary_is_prefix cons nil nil t)                       true)
        (($nary_is_prefix cons nil t nil)                       false)
        (($nary_is_prefix cons nil (cons c1 xs1) (cons c2 xs2)) (eo::ite (eo::is_eq c1 c2) ($nary_is_prefix cons nil xs1 xs2) false))
    )
)

; program: $nary_is_compatible
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c1 T1: The first term, assumed to be a cons-list.
; - c2 T1: The second term, assumed to be a cons-list.
; return: true if c1 is a prefix of c2, or c2 is a prefix of c1.
(program-schema :right-assoc-nil $nary_is_compatible
    ((T1 Type) (t T1) (c1 T1) (c2 T1) (xs1 T1 :list) (xs2 T1 :list) (cons (-> T1 T1 T1)) (nil T1))
    ((-> T1 T1 T1) T1 T1 T1) Bool
    (
        (($nary_is_compatible cons nil nil t)                       true)
        (($nary_is_compatible cons nil t nil)                       true)
        (($nary_is_compatible cons nil (cons c1 xs1) (cons c2 xs2)) (eo::ite (eo::is_eq c1 c2) ($nary_is_compatible cons nil xs1 xs2) false))
    )
)

; program: $nary_prefix
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - l Int: The number of elements in the prefix left to extract.
; - t T1: The term to process, which is expected to be a cons-list.
; return: the prefix of t consisting of at most l children.
(program-schema :right-assoc-nil $nary_prefix
    ((T1 Type) (t T1) (c1 T1) (c2 T1 :list) (l eo::Int) (cons (-> T1 T1 T1)) (nil T1))
    ((-> T1 T1 T1) T1 eo::Int T1) T1
    (
        (($nary_prefix cons nil l nil)             nil)
        (($nary_prefix cons nil eo::0 t)            nil)
        (($nary_prefix cons nil l (cons c1 c2))    (eo::cons cons c1 ($nary_prefix cons nil (eo::add l eo::-1) c2)))
    )
)

; program: $nary_subsequence
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - l Int: The starting index, inclusive, of elements of t to extract.
; - u Int: The end index, inclusive, of elements of t to extract.
; - t T1: The term to process, which is expected to be a cons-list.
; return: >
;   The subsequent of t between indices l and u inclusive. Indices that
;   fall out of bounds of the number of children of t are ignored.
(program-schema :right-assoc-nil $nary_subsequence
    ((T1 Type) (cons (-> T1 T1 T1)) (nil T1) (t T1) (c1 T1) (c2 T1 :list) (u eo::Int) (l eo::Int))
    ((-> T1 T1 T1) T1 eo::Int eo::Int T1) T1
    (
        (($nary_subsequence cons nil l u nil)            nil)
        (($nary_subsequence cons nil eo::0 u t)           ($nary_prefix cons nil (eo::add u eo::1) t))
        (($nary_subsequence cons nil l u (cons c1 c2))   ($nary_subsequence cons nil (eo::add l eo::-1) (eo::add u eo::-1) c2))
    )
)

; program: $nary_join
; args:
; - cons (-> T1 T1 T1): The n-ary function symbol.
; - nil T1: The nil terminator of cons.
; - c1 T1: The first term, assumed to be a cons-list.
; - c2 T1: The second term, assumed to be a cons-list.
; return: >
;   The "join" of c1 and c2, that is, if the last child of c1 is the same as the
;   first child of c2, then those 2 children are dropped and c1 and c2 are
;   appended together. Otherwise, this program-schema does not evaluate.
(program-schema :right-assoc-nil $nary_join
    ((T1 Type) (cons (-> T1 T1 T1)) (nil T1) (x T1) (xs T1 :list) (y T1) (ys T1 :list))
    ((-> T1 T1 T1) T1 T1 T1) T1
    (
        (($nary_join cons nil (cons x nil) (cons x ys)) ys)
        (($nary_join cons nil (cons x xs) y)            (cons x ($nary_join cons nil xs y)))
    )
)

; program: $nary_diff
; args:
; - cons (-> T1 T1 T1): >
;   The function whose applications we are considering. It is assumed that
;   cons is a function with attribute :right-assoc-nil.
; - nil T1: The nil terminator of cons.
; - t1 T1: The first term, assumed to be a cons-list.
; - t2 T1: The second term, assumed to be a cons-list.
; return: >
;   The result of subtracting t2 from t1, where these terms are cons-lists.
;   For example, ($nary_diff or false (or a b c d) (or a c)) = (or b d).
;   This is different from set difference, in that we eliminate elements of the
;   list only in order. This corresponds to set difference only if the lists are
;   both ordered.
(program-schema :right-assoc-nil $nary_diff
    ((T1 Type) (cons (-> T1 T1 T1)) (nil T1) (t T1) (c1 T1) (c2 T1) (xs1 T1 :list) (xs2 T1 :list))
    ((-> T1 T1 T1) T1 T1 T1) T1
    (
        (($nary_diff cons nil (cons c1 xs1) (cons c2 xs2))  (eo::ite (eo::is_eq c1 c2)
                                                              ($nary_diff cons nil xs1 xs2)
                                                              (eo::cons cons c1 ($nary_diff cons nil xs1 (cons c2 xs2)))))
        (($nary_diff cons nil c1 nil)                       c1)
    )
)
