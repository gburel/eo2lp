; =============================================================================
;
; This is the official development version of the Eunoia signature for the
; Cooperating Proof Calculus. It is a faithful formalization of cvc5's theory
; signatures and proof rules.
;
; NOTE: cvc5 does not strictly follow the SMT-LIB version 2.6 standard. In
; particular, it contains many extensions, including non-standard theories as
; well as non-standard extensions of existing theories. Moreover, some standard
; theory symbols have subtle differences with the SMT-LIB standard.
;
; For examples of the latter:
; - Many arithmetic symbols in cvc5 such as +, *, >= operate on *mixed*
; arithmetic. That is, they can be applied to mixtures of Real and Int.
; - Most associative operators are modelled as variadic (modelled in Eunoia as
; :left-assoc-nil and :right-assoc-nil) instead of being seen as syntax sugar
; for an associative chain that does not distinguish a nil terminator (e.g.
; :left-assoc and :right-assoc). Examples of these operators include or, bvand,
; +, and so on.
; - cvc5 generalizes strings to sequences, so that strings are defined to be
; (Seq Char).
; - We model quantifiers (forall, exists) using explicit function symbols taking
; lists to model their binders.
; Whenever applicable, these differences are marked with disclaimer: comments.
;
; Furthermore, this signature is designed to capture the exact definition of
; cvc5's proof API. That is, Proof objects in our API are expected to have the
; same expected arguments and premises as their formal definition in this
; signature.
;
; This signature however intentionally does *not* formalize any proof rules that
; are prefixed by MACRO_. These can be eliminated using the cvc5 option
; --proof-granularity=theory-rewrite or --proof-granularity=dsl-rewrite.
;
; The cases of ProofRule::THEORY_REWRITE are each formalized as individual
; proof rules. Similarly, each theory rewrite with a ProofRewriteRule that
; is prefixed by MACRO_ are not formalized in this signature and will not
; appear in final proofs.
;
; The cases of ProofRule::DSL_REWRITE are each formalized as individual
; proof rules in ./rules/Rewrites.eo.
;
; The rules ProofRule::TRUST and ProofRule::TRUST_THEORY_REWRITE are output in
; proofs using a catch-all rule trust defined at the end of this file. This
; rule is also used for any ProofRule which the Eunoia signature does not
; currently support. In cvc5's proof ouput, an Eunoia comment will be displayed
; above an application of this rule to indicate diagnostic information on the
; source of this inference, in the format of a TrustId, tracked internally in
; cvc5 to classify the source of the incompleteness.
;
; !!! NOTE: proofs using any instance of the trust rule should be considered
; incomplete and not having a formal justification. The Ethos checker will
; output "incomplete" if any trust step appears in a proof.
;
; Discrepancies between cvc5's Proof API and the formal Eunoia definition are
; also noted when applicable by disclaimer:.
;
; =============================================================================

;(include "./rules/Builtin.eo")
(include "./rules/Booleans-less.eo")
(include "./rules/Uf.eo")
(include "./rules/Rewrites-less.eo")

; program: $run_evaluate
; args:
; - t S: The term to evaluate.
; conclusion: The result of evaluating t.
(program $run_evaluate
  ((T Type) (S Type) (x T) (y T) (z S) (b Bool) (bs Bool :list))
  (S) S
  (
    (($run_evaluate (= x y))       (eo::is_eq ($run_evaluate x) ($run_evaluate y)))
    (($run_evaluate (ite b x y))   (eo::ite ($run_evaluate b) ($run_evaluate x) ($run_evaluate y)))
    (($run_evaluate (not b))       (eo::not ($run_evaluate b)))
    (($run_evaluate (or b bs))     (eo::or ($run_evaluate b) ($run_evaluate bs)))
    (($run_evaluate (and b bs))    (eo::and ($run_evaluate b) ($run_evaluate bs)))
    (($run_evaluate (xor b bs))    (eo::xor ($run_evaluate b) ($run_evaluate bs)))
    (($run_evaluate z)             z)
  )
)

; rule: evaluate
; implements: ProofRule::EVALUATE
; args:
; - t U: The term to evaluate.
; conclusion: The term t is equal to what it evaluates to.
(declare-rule evaluate ((U Type) (t U))
  :args (t)
  :conclusion (= t ($run_evaluate t))
)

(define foo () (@list true))
