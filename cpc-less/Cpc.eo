; =============================================================================
;
; This is the official development version of the Eunoia signature for the
; Cooperating Proof Calculus. It is a faithful formalization of cvc5's theory
; signatures and proof rules.
;
; NOTE: cvc5 does not strictly follow the SMT-LIB version 2.6 standard. In
; particular, it contains many extensions, including non-standard theories as
; well as non-standard extensions of existing theories. Moreover, some standard
; theory symbols have subtle differences with the SMT-LIB standard.
;
; For examples of the latter:
; - Many arithmetic symbols in cvc5 such as +, *, >= operate on *mixed*
; arithmetic. That is, they can be applied to mixtures of Real and Int.
; - Most associative operators are modelled as variadic (modelled in Eunoia as
; :left-assoc-nil and :right-assoc-nil) instead of being seen as syntax sugar
; for an associative chain that does not distinguish a nil terminator (e.g.
; :left-assoc and :right-assoc). Examples of these operators include or, bvand,
; +, and so on.
; - cvc5 generalizes strings to sequences, so that strings are defined to be
; (Seq Char).
; - We model quantifiers (forall, exists) using explicit function symbols taking
; lists to model their binders.
; Whenever applicable, these differences are marked with disclaimer: comments.
;
; Furthermore, this signature is designed to capture the exact definition of
; cvc5's proof API. That is, Proof objects in our API are expected to have the
; same expected arguments and premises as their formal definition in this
; signature.
;
; This signature however intentionally does *not* formalize any proof rules that
; are prefixed by MACRO_. These can be eliminated using the cvc5 option
; --proof-granularity=theory-rewrite or --proof-granularity=dsl-rewrite.
;
; The cases of ProofRule::THEORY_REWRITE are each formalized as individual
; proof rules. Similarly, each theory rewrite with a ProofRewriteRule that
; is prefixed by MACRO_ are not formalized in this signature and will not
; appear in final proofs.
;
; The cases of ProofRule::DSL_REWRITE are each formalized as individual
; proof rules in ./rules/Rewrites.eo.
;
; The rules ProofRule::TRUST and ProofRule::TRUST_THEORY_REWRITE are output in
; proofs using a catch-all rule trust defined at the end of this file. This
; rule is also used for any ProofRule which the Eunoia signature does not
; currently support. In cvc5's proof ouput, an Eunoia comment will be displayed
; above an application of this rule to indicate diagnostic information on the
; source of this inference, in the format of a TrustId, tracked internally in
; cvc5 to classify the source of the incompleteness.
;
; !!! NOTE: proofs using any instance of the trust rule should be considered
; incomplete and not having a formal justification. The Ethos checker will
; output "incomplete" if any trust step appears in a proof.
;
; Discrepancies between cvc5's Proof API and the formal Eunoia definition are
; also noted when applicable by disclaimer:.
;
; =============================================================================

;(include "./rules/Builtin.eo")
(include "./rules/Booleans-less.eo")
(include "./rules/Uf.eo")
(include "./rules/Rewrites-less.eo")

; program: $run_evaluate
; args:
; - t S: The term to evaluate.
; conclusion: The result of evaluating t.
(program $run_evaluate
  ((T Type) (S Type) (x T) (y T) (z S) (b Bool) (bs Bool :list))
  (S) S
  (
    (($run_evaluate (= x y))       (eo::is_eq ($run_evaluate x) ($run_evaluate y)))
    (($run_evaluate (ite b x y))   (eo::ite ($run_evaluate b) ($run_evaluate x) ($run_evaluate y)))
    (($run_evaluate (not b))       (eo::not ($run_evaluate b)))
    (($run_evaluate (or b bs))     (eo::or ($run_evaluate b) ($run_evaluate bs)))
    (($run_evaluate (and b bs))    (eo::and ($run_evaluate b) ($run_evaluate bs)))
    (($run_evaluate (xor b bs))    (eo::xor ($run_evaluate b) ($run_evaluate bs)))
    (($run_evaluate z)             z)
  )
)

; rule: evaluate
; implements: ProofRule::EVALUATE
; args:
; - t U: The term to evaluate.
; conclusion: The term t is equal to what it evaluates to.
(declare-rule evaluate ((U Type) (t U))
  :args (t)
  :conclusion (= t ($run_evaluate t))
)

; program: $get_aci_norm
; args:
; - t Bool: The term to process.
; return: the result of normalizing t based on ACI reasoning.
(program $get_aci_norm
  ((x Bool) (xs Bool :list))
  (Bool) Bool
  (
    (($get_aci_norm (or x xs)) ($singleton_elim_aci or false ($get_aci_norm_rec or false (or x xs))))
    (($get_aci_norm (and x xs)) ($singleton_elim_aci and true ($get_aci_norm_rec and true (and x xs))))
  )
)

; define: $get_aci_normal_form
; args:
; - t S: The term to compute the normal form for.
; return: >
;   The result of normalizing t for the proof rule aci_norm. In
;   particular, if t is an application of a known operator that has the property
;   of being either associative and commutative (resp. associative) we call
;   the method $get_aci_norm (resp. $get_a_norm).
(program $get_aci_normal_form
  ((x1 Bool) (x2 Bool :list))
  (Bool) Bool
  (
    (($get_aci_normal_form (or x1 x2))  ($get_aci_norm (or x1 x2)))
    (($get_aci_normal_form (and x1 x2)) ($get_aci_norm (and x1 x2)))
    (($get_aci_normal_form x1)           x1)
  )
)

; rule: aci_norm
; implements: ProofRule::ACI_NORM
; args:
; - eq Bool: The equality to be proven by this rule.
; requires: >
;   That computing the normal forms via $get_aci_normal_form of the sides of the
;   given equality between terms a and b suffices to show that a and b are
;   equivalent. Note that we need three checks. The first two handle the cases
;   where one side is treated as a singleton child of the other side. The
;   remaining case checks where both terms are not singletons.
; conclusion: The given equality.
(declare-rule aci_norm ((U Type) (a U) (b U))
  :args ((= a b))
  :requires (((eo::define ((an ($get_aci_normal_form a)) (bn ($get_aci_normal_form b)))
              (eo::ite (eo::is_eq an b) true
              (eo::ite (eo::is_eq a bn) true
                (eo::is_eq an bn)))) true))
  :conclusion (= a b)
)
