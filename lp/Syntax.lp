require open Logic.U.Arrow;

symbol ğ’® : TYPE;
builtin "String" â‰” ğ’®;
symbol string : Set;

symbol List : TYPE;
injective symbol list : Set â†’ Set;
injective symbol â‹… [a] : El (list a);
injective symbol â¨¾ [a] : El (a â¤³ list a â¤³ list a);
notation â¨¾ infix right 10;

symbol map [a b] : El ((a â¤³ b) â¤³ list a â¤³ list b);
rule (map $f (â‹…)) â†ª (â‹…)
with (map $f ($x â¨¾ $xs)) â†ª ($f $x) â¨¾ (map $f $xs);

// type of eo terms
symbol eo : Set;
injective symbol sym : El (string â¤³ eo);
injective symbol app : El (string â¤³ list eo â¤³ eo);


type (app "and" (cons "true" (cons "true" nil)));

symbol eo' : Set;
injective symbol sym' : El (string â¤³ eo');
injective symbol app' : El (eo' â¤³ eo' â¤³ eo');

symbol elaborate : El (eo â¤³ eo');

symbol ctyp : El (string) â†’ Set;
symbol ctm  (s : El string) : El (ctyp s);

symbol interp : El (eo' â¤³ eo' â¤³ ....)




symbol Halt : El eo;

symbol EO : TYPE â‰” El eo;

// every symbol annotated with a type
injective symbol !! : ğ’® â†’ EO â†’ EO;
injective symbol --> : El (list eo â¤³ eo);
injective symbol Type : El eo;

// given an arrow type `-> t1 .. tn`, and a list `e1 .. e_(n-1)`
// return `tn`, checking that each `t_i == e_i` for each i .. n-1.
sequential symbol app_tys : El (eo â¤³ list eo â¤³ eo);
rule app_tys (--> ($e â¨¾ â‹…)) (â‹…) â†ª $e
with app_tys (--> ($e â¨¾ $es)) ($e â¨¾ $es')
  â†ª (app_tys (--> $es) $es')
with app_tys (--> ($e â¨¾ _)) ($e' â¨¾ _) â†ª Halt
with app_tys (--> â‹…) _ â†ª Halt // empty arrow type, halt.
with app_tys _ _ â†ª Halt; // not an eo term denoting a function type, so halt.

// calculate the type of `e : EO` as an `EO`.
// needs to change to compensate for n-ary operations.
sequential symbol ty : EO â†’ EO;
rule (ty (!! $str $t)) â†ª ($t)
with (ty (app $e $es)) â†ª (app_tys (ty $e) (map ty $es));


symbol HALT : TYPE;
symbol âˆ… : Set;

// interpret a Eunoia kind as a type.
sequential symbol Ki : EO â†’ TYPE;
rule (Ki Type) â†ª Set
with (Ki Halt) â†ª HALT
with (Ki (--> ($e â¨¾ â‹…))) â†ª Ki $e
with (Ki (--> ($e â¨¾ $es))) â†ª Ki $e â†’ (Ki (--> $es));


injective symbol ğš» : ğ’® â†’ Set;

// interpret a Eunoia type as a set-code.
sequential symbol Ty : EO â†’ Set;
rule (Ty Halt) â†ª âˆ…
with (Ty Type) â†ª âˆ…
with (Ty (!! $str Type)) â†ª ğš» $str
//with (Ty (app (!! $str Type)) $es) â†ª ğš» $str
with (Ty (--> ($e â¨¾ â‹…)))   â†ª Ty $e
with (Ty (--> ($e â¨¾ $es))) â†ª Ty $e â¤³ (Ty (--> $es));

// some tests.
symbol b â‰” (!! "Bool" Type);
symbol l â‰” (!! "List" (--> (Type â¨¾ Type â¨¾ â‹…)));

symbol lc â‰” (!! "and" (--> (b â¨¾ b â¨¾ b â¨¾ â‹…)));
symbol t â‰” (!! "true" (b));

compute Ty (ty (app (lc) (t â¨¾ t â¨¾ â‹…)));

symbol lctt â‰” (app lc (t â¨¾ t â¨¾ â‹…));

compute Ty (ty (lctt));

symbol lb â‰” (app l (b â¨¾ â‹…));
compute Ty (ty l);

compute ty (app lc (t â¨¾ t â¨¾ â‹…));



sequential symbol tm (str : ğ’®) : ty str;
// rw. rules defined throughout translation. e.g.,
rule (tm "Bool") â†ª Bool;
rule (tm "and")  â†ª and;

symbol foldl [a b] :
  El ((b â¤³ a â¤³ b) â¤³ b â¤³ list a â¤³ b);
rule (foldl $f $acc (â‹…)) â†ª $acc
with (foldl $f $acc ($x â¨¾ $xs)) â†ª foldl $f ($f $acc $x) $xs;

symbol eo' : Set;
symbol EO' : TYPE â‰” El eo';

injective symbol !! : ğ’® â†’ EO' â†’ EO';
injective symbol __ : EO' â†’ EO' â†’ EO';

symbol elab : EO â†’ EO';
rule (elab (sym $str)) â†ª (sym' $str)
with (elab (app $str $es))
  â†ª foldl (Î» acc e, __ acc e) (!! $str $t) (map elab $es);

compute
  let foo â‰” app "and" (sym "true" â¨¾ sym "true" â¨¾ â‹…) in
  elab foo;

symbol Typ : EO' â†’ TYPE;
symbol ty_of : EO' â†’ EO';

symbol ev_tm : (Î  e : EO', Typ (ty_of e));

rule (Typ (sym' "Type")) â†ª Set;
rule (ty_of (sym' "Type")) â†ª (sym' "Kind");

rule (ty_of (sym' "Bool")) â†ª (sym' "Type");
rule (ev_tm (sym' "Bool")) â†ª Bool;
rule (Typ (sym' "Bool")) â†ª El Bool;

compute ev_tm (sym' "Bool");

rule (ty_of (sym' "not")) â†ª ( "Type");
rule (ev_tm (sym' "Bool")) â†ª Bool;
rule (Typ (sym' "Bool")) â†ª El Bool;
